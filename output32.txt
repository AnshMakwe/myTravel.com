
The file 'stake.js' (Path: /home/vboxuser/sec-try/fabric-samples/chaincode/contract/javascript/lib/stake.js) contains:

'use strict';

const { Contract } = require('fabric-contract-api');

const customerPrefix = 'customer';
const providerPrefix = 'provider';
const travelOptionPrefix = 'travelOption';
const ticketPrefix = 'ticket';

class TravelTicket extends Contract {

    /**
     * Initialize the ledger.
     * Optionally add pre-defined travel options or sample data.
     */
    async initLedger(ctx) {
        console.info('=== Initializing Ledger ===');
        // Optionally add pre-defined travel options or sample data here.
        console.info('Ledger initialization complete.');
    }

    /**
     * Register a new customer.
     * @param {Context} ctx The transaction context.
     * @param {String} name Customer name.
     * @param {String} contact Customer contact details.
     */
    async registerCustomer(ctx, name, contact) {
        const customerId = ctx.clientIdentity.getID();
        const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
        const customerBytes = await ctx.stub.getState(customerKey);
        if (customerBytes && customerBytes.length > 0) {
            throw new Error('Customer already registered.');
        }
        const customerData = {
            customerId,
            wallet: customerId,
            name,
            contact,
            balance: 1000,
            bookings: []  // list of ticket composite keys
        };
        await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
        return customerData;
    }

    /**
     * Register a new service provider.
     * @param {Context} ctx The transaction context.
     * @param {String} name Provider name.
     * @param {String} contact Provider contact details.
     * @param {Number} rating Provider rating (optional).
     */
    async registerProvider(ctx, name, contact, rating, serviceProvider) {
        const providerId = ctx.clientIdentity.getID();
        const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
        const providerBytes = await ctx.stub.getState(providerKey);
        if (providerBytes && providerBytes.length > 0) {
            throw new Error('Provider already registered.');
        }
        const providerData = {
            providerId,
            name,
            contact,
            rating: rating || 0,
            numRatings: 0,// number of ratings received
            serviceProvider,
            balance: 100,         
            travelOptions: []   
        };
        await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
        return providerData;
    }

    /**
     * Update customer details.
     * Optionally mark the profile as anonymous (contact info set to null).
     */
    async updateCustomerDetails(ctx, newName, newContact, isAnonymous) {
    const customerId = ctx.clientIdentity.getID();
    const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
    const customerBytes = await ctx.stub.getState(customerKey);
    if (!customerBytes || customerBytes.length === 0) {
        throw new Error('Customer not registered.');
    }
    let customerData = JSON.parse(customerBytes.toString());
    
    // Convert isAnonymous to boolean if it is a string.
    const anonymousFlag = typeof isAnonymous === 'string' 
      ? isAnonymous.toLowerCase() === 'true' 
      : Boolean(isAnonymous);
    
    customerData.name = anonymousFlag ? '_____' : (newName || customerData.name);
    customerData.contact = anonymousFlag ? null : (newContact || customerData.contact);
    
    await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
    return customerData;
}




    
    /**
     * Deposit funds into the customer's wallet.
     * @param {Context} ctx The transaction context.
     * @param {String} amount The amount to deposit.
     */
    async depositFunds(ctx, amount) {
        const customerId = ctx.clientIdentity.getID();
        const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
        const customerBytes = await ctx.stub.getState(customerKey);
        if (!customerBytes || customerBytes.length === 0) {
            throw new Error('Customer not registered.');
        }
        let customerData = JSON.parse(customerBytes.toString());
        const depositAmount = parseFloat(amount);
        if (isNaN(depositAmount) || depositAmount <= 0) {
            throw new Error('Deposit amount must be a positive number.');
        }
        customerData.balance += depositAmount;
        await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
        return customerData;
    }

    /**
     * Update provider details.
     * Optionally mark the profile as anonymous (contact info set to null).
     */
    async updateProviderDetails(ctx, newName, newContact, newRating, isAnonymous) {
        const providerId = ctx.clientIdentity.getID();
        const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
        const providerBytes = await ctx.stub.getState(providerKey);
        if (!providerBytes || providerBytes.length === 0) {
            throw new Error('Provider not registered.');
        }
        let providerData = JSON.parse(providerBytes.toString());
        providerData.name = newName || providerData.name;
        providerData.contact = isAnonymous ? null : (newContact || providerData.contact);
        providerData.rating = providerData.rating;
        await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
        return providerData;
    }

    /**
 * Provider adds a new travel option.
 * @param {Context} ctx The transaction context.
 * @param {String} source Starting location.
 * @param {String} destination Destination.
 * @param {String} departureDate Date of departure (ISO string recommended).
 * @param {String} departureTime Departure time.
 * @param {String} transportMode Mode of transport (plane, train, bus).
 * @param {Number} seatCapacity Total seats available.
 * @param {Number} basePrice Base ticket price.
 */
async addTravelOption(ctx, source, destination, departureDate, departureTime, transportMode, seatCapacity, basePrice) {
    // Get provider info.
    const providerId = ctx.clientIdentity.getID();
    const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
    const providerBytes = await ctx.stub.getState(providerKey);
    if (!providerBytes || providerBytes.length === 0) {
        throw new Error('Provider not registered.');
    }
    let providerData = JSON.parse(providerBytes.toString());
    
    
    providerData.balance -= 5;

    // Check for duplicate active (non-cancelled) travel option by the same provider.
    // Loop through travel options already registered by this provider.
    for (const existingOptionId of providerData.travelOptions) {
        const existingOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [existingOptionId]);
        const existingOptionBytes = await ctx.stub.getState(existingOptionKey);
        if (existingOptionBytes && existingOptionBytes.length > 0) {
            const existingOption = JSON.parse(existingOptionBytes.toString());
            // Only check travel options that are not cancelled (if you add a "status" field to travel options,
            // assume that a cancelled travel option would have status 'CANCELLED'; if status does not exist, then always check)
            if (!existingOption.status || existingOption.status !== 'CANCELLED') {
                if (
                    existingOption.source === source &&
                    existingOption.destination === destination &&
                    existingOption.departureDate === departureDate &&
                    existingOption.departureTime === departureTime &&
                    existingOption.transportMode === transportMode &&
                    parseInt(existingOption.seatCapacity) === parseInt(seatCapacity) &&
                    parseFloat(existingOption.basePrice) === parseFloat(basePrice)
                ) {
                    throw new Error('A non cancelled travel option with the same details already exists.');
                }
            }
        }
    }

    // Generate a new travel option id using current time.
    const txTimestamp = ctx.stub.getTxTimestamp();
    const timestamp = txTimestamp.seconds.low.toString();
    const travelOptionId = `${source}_${destination}_${departureDate}_${departureTime}_${providerId}_${timestamp}`;
    const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);

    const travelOptionData = {
        travelOptionId,
        providerId,
        serviceProvider: providerData.serviceProvider,
        source,
        destination,
        departureDate,
        departureTime,
        transportMode,
        bookedSeats: [],
        seatCapacity: parseInt(seatCapacity),
        availableSeats: parseInt(seatCapacity),
        basePrice: parseFloat(basePrice)
    };
    await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));
    providerData.travelOptions.push(travelOptionId);
    await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
    return travelOptionData;
}





    /**
     * List travel options matching source and destination.
     */
    async listTravelOptions(ctx, source, destination) {
        const iterator = await ctx.stub.getStateByPartialCompositeKey(travelOptionPrefix, []);
        const options = [];
        while (true) {
            const res = await iterator.next();
            if (res.value && res.value.value.toString()) {
                const record = JSON.parse(res.value.value.toString('utf8'));
                if (record.source === source && record.destination === destination) {
                    options.push(record);
                }
            }
            if (res.done) {
                await iterator.close();
                return options;
            }
        }
    }

    /**
     * List travel options sorted by criteria with additional filtering:
     * price range, specific provider, and availability.
     * @param {Context} ctx The transaction context.
     * @param {String} source Starting location.
     * @param {String} destination Destination.
     * @param {String} sortBy One of 'price', 'rating', or 'transportMode'.
     * @param {String} [minPrice] (Optional) Minimum price filter.
     * @param {String} [maxPrice] (Optional) Maximum price filter.
     * @param {String} [filterProviderId] (Optional) Specific provider ID filter.
     * @param {String} [onlyAvailable] (Optional) "true" to include only options with available seats.
     */
    async listTravelOptionsSorted(ctx, source, destination, inputdate, sortBy, minPrice, maxPrice, filterProviderId, onlyAvailable) {
    let options = await this.listTravelOptions(ctx, source, destination);
    
    // Filter by inputdate (only keep travel options on the specified departure date)
    if (inputdate) {
        options = options.filter(opt => opt.departureDate === inputdate);
    }
    
    // Filter by availability.
    if (onlyAvailable && onlyAvailable.toLowerCase() === 'true') {
        options = options.filter(opt => opt.availableSeats > 0);
    }
    // Filter by price range.
    if (minPrice) {
        options = options.filter(opt => parseFloat(opt.basePrice) >= parseFloat(minPrice));
    }
    if (maxPrice) {
        options = options.filter(opt => parseFloat(opt.basePrice) <= parseFloat(maxPrice));
    }
    // Filter by a specific provider.
    if (filterProviderId) {
        options = options.filter(opt => opt.serviceProvider === filterProviderId);
    }
    // Enrich options with provider rating if sorting by rating.
    for (let i = 0; i < options.length; i++) {
            const providerKey = ctx.stub.createCompositeKey(providerPrefix, [options[i].providerId]);
            const providerBytes = await ctx.stub.getState(providerKey);
            if (providerBytes && providerBytes.length > 0) {
                const providerData = JSON.parse(providerBytes.toString());
                options[i].providerRating = providerData.rating;
                options[i].totalRating = providerData.numRatings;
            } else {
                options[i].providerRating = 0;
                options[i].totalRating = 0;
            }
        }
    if (sortBy === 'price') {
        options.sort((a, b) => a.basePrice - b.basePrice);
    } else if (sortBy === 'rating') {
        options.sort((a, b) => b.providerRating - a.providerRating);
    } else if (sortBy === 'transportMode') {
        options.sort((a, b) => a.transportMode.localeCompare(b.transportMode));
    }
    return options;
}





    /**
     * Book a ticket for a given travel option.
     * Implements dummy payment and dynamic pricing using a deterministic timestamp.
     * Added simulation for block confirmations.
     * @param {Context} ctx The transaction context.
     * @param {String} travelOptionId The travel option identifier.
     */
async bookTicket(ctx, travelOptionId, seatnumber) {
    const customerId = ctx.clientIdentity.getID();
    const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
    const customerBytes = await ctx.stub.getState(customerKey);
    if (!customerBytes || customerBytes.length === 0) {
        throw new Error('Customer not registered.');
    }
    let customerData = JSON.parse(customerBytes.toString());

    const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
    const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
    if (!travelOptionBytes || travelOptionBytes.length === 0) {
        throw new Error('Travel option does not exist.');
    }
    let travelOptionData = JSON.parse(travelOptionBytes.toString());

    // Validate that there are still available seats overall.
    if (travelOptionData.availableSeats <= 0) {
        throw new Error('No seats available.');
    }

    // Parse and validate the requested seat number.
    const requestedSeatNumber = parseInt(seatnumber, 10);
    if (isNaN(requestedSeatNumber) || requestedSeatNumber < 1 || requestedSeatNumber > travelOptionData.seatCapacity) {
        throw new Error('Seat number must be a number between 1 and the maximum seat capacity.');
    }

    // First check using an iterator over existing tickets (as before)
    const ticketIterator = await ctx.stub.getStateByPartialCompositeKey(ticketPrefix, [travelOptionId]);
    while (true) {
        const res = await ticketIterator.next();
        if (res.value && res.value.value.toString()) {
            let ticket = JSON.parse(res.value.value.toString('utf8'));
            // Consider a seat booked if its ticket status is not CANCELLED.
            if (ticket.status !== 'CANCELLED' && ticket.seatNumber === requestedSeatNumber) {
                await ticketIterator.close();
                throw new Error('Requested seat number is already booked.');
            }
        }
        if (res.done) {
            await ticketIterator.close();
            break;
        }
    }

    // NEW CHECK: Using the bookedSeats array in the travel option (if maintained)
    if (travelOptionData.bookedSeats && Array.isArray(travelOptionData.bookedSeats)) {
        if (travelOptionData.bookedSeats.includes(requestedSeatNumber)) {
            throw new Error('Requested seat number is already booked.');
        }
    }

    // Calculate dynamic pricing as before.
    const bookedCount = travelOptionData.seatCapacity - travelOptionData.availableSeats;
    const occupancyFactor = bookedCount / travelOptionData.seatCapacity;
    const dynamicFactor = 0.5;
    let dynamicPrice = travelOptionData.basePrice * (1 + occupancyFactor * dynamicFactor);
    const maxPrice = travelOptionData.basePrice * 1.5;
    if (dynamicPrice > maxPrice) {
        dynamicPrice = maxPrice;
    }

    if (customerData.balance < dynamicPrice) {
        throw new Error('Insufficient balance for booking.');
    }
    customerData.balance -= (dynamicPrice+5);

    const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
    const providerBytes = await ctx.stub.getState(providerKey);
    let providerData = JSON.parse(providerBytes.toString());
    providerData.balance += dynamicPrice;

    // Update customer and provider data.
    await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
    await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));

    // Decrement available seats by 1 and update bookedSeats.
    travelOptionData.availableSeats -= 1;
    if (!travelOptionData.bookedSeats) {
        travelOptionData.bookedSeats = [];
    }
    travelOptionData.bookedSeats.push(requestedSeatNumber);
    await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));

    // Get transaction timestamp and use it for ticket composite key.
    const txTimestamp = ctx.stub.getTxTimestamp();
    const timestamp = txTimestamp.seconds.low.toString();
    const bookingTime = new Date(txTimestamp.seconds.low * 1000).toISOString();
    const ticketCompositeKey = ctx.stub.createCompositeKey(ticketPrefix, [travelOptionId, customerId, timestamp]);
    const encodedKey = Buffer.from(ticketCompositeKey).toString('base64').toString('utf8');

    // Create the ticket using the requested seat number.
    const ticketData = {
        ticketId: ticketCompositeKey,
        travelOptionId,
        customerId,
        encodedKey,
        seatNumber: requestedSeatNumber,
        bookingTime,
        timestamp,
        pricePaid: dynamicPrice,
        // New fields for confirmation simulation and pricing transparency:
        status: 'PENDING_CONFIRMATION',
        confirmationCount: 0,
        pricingBreakdown: {
            basePrice: travelOptionData.basePrice,
            occupancyFactor: occupancyFactor,
            dynamicFactor: dynamicFactor,
            dynamicPrice: dynamicPrice
        }
    };

    await ctx.stub.putState(ticketCompositeKey, Buffer.from(JSON.stringify(ticketData)));
    customerData.bookings.push(ticketCompositeKey);
    await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));

    return ticketData;
}





async bookTicket1(ctx, travelOptionId, seatnumber, customerRefund, oldProviderKey) {
    const customerId = ctx.clientIdentity.getID();
    const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
    const customerBytes = await ctx.stub.getState(customerKey);
    if (!customerBytes || customerBytes.length === 0) {
        throw new Error('Customer not registered.');
    }
    let customerData = JSON.parse(customerBytes.toString());

    const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
    const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
    if (!travelOptionBytes || travelOptionBytes.length === 0) {
        throw new Error('Travel option does not exist.');
    }
    let travelOptionData = JSON.parse(travelOptionBytes.toString());

    // Validate that there are still available seats overall.
    if (travelOptionData.availableSeats <= 0) {
        throw new Error('No seats available.');
    }

    // Parse and validate the requested seat number.
    const requestedSeatNumber = parseInt(seatnumber, 10);
    if (isNaN(requestedSeatNumber) || requestedSeatNumber < 1 || requestedSeatNumber > travelOptionData.seatCapacity) {
        throw new Error('Seat number must be a number between 1 and the maximum seat capacity.');
    }

    // First check using an iterator over existing tickets (as before)
    const ticketIterator = await ctx.stub.getStateByPartialCompositeKey(ticketPrefix, [travelOptionId]);
    while (true) {
        const res = await ticketIterator.next();
        if (res.value && res.value.value.toString()) {
            let ticket = JSON.parse(res.value.value.toString('utf8'));
            // Consider a seat booked if its ticket status is not CANCELLED.
            if (ticket.status !== 'CANCELLED' && ticket.seatNumber === requestedSeatNumber) {
                await ticketIterator.close();
                throw new Error('Requested seat number is already booked.');
            }
        }
        if (res.done) {
            await ticketIterator.close();
            break;
        }
    }

    // NEW CHECK: Using the bookedSeats array in the travel option (if maintained)
    if (travelOptionData.bookedSeats && Array.isArray(travelOptionData.bookedSeats)) {
        if (travelOptionData.bookedSeats.includes(requestedSeatNumber)) {
            throw new Error('Requested seat number is already booked.');
        }
    }

    // Calculate dynamic pricing as before.
    const bookedCount = travelOptionData.seatCapacity - travelOptionData.availableSeats;
    const occupancyFactor = bookedCount / travelOptionData.seatCapacity;
    const dynamicFactor = 0.5;
    let dynamicPrice = travelOptionData.basePrice * (1 + occupancyFactor * dynamicFactor);
    const maxPrice = travelOptionData.basePrice * 1.5;
    if (dynamicPrice > maxPrice) {
        dynamicPrice = maxPrice;
    }

    if (customerData.balance < dynamicPrice) {
        throw new Error('Insufficient balance for booking.');
    }
    customerData.balance += customerRefund;
    customerData.balance -= dynamicPrice;

    const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
    const providerBytes = await ctx.stub.getState(providerKey);
    let providerData = JSON.parse(providerBytes.toString());
    
    const oldproviderBytes = await ctx.stub.getState(oldProviderKey);
    let oldproviderData = JSON.parse(oldproviderBytes.toString());
    if(providerKey === oldProviderKey)
    {
        providerData.balance -= customerRefund;
        providerData.balance += dynamicPrice;
    }
    else
    {
        oldproviderData.balance -= customerRefund;
        providerData.balance += dynamicPrice;   
        await ctx.stub.putState(oldProviderKey, Buffer.from(JSON.stringify(oldproviderData)));
    }
    

    // Update customer and provider data.
    await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
    await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));

    // Decrement available seats by 1 and update bookedSeats.
    travelOptionData.availableSeats -= 1;
    if (!travelOptionData.bookedSeats) {
        travelOptionData.bookedSeats = [];
    }
    travelOptionData.bookedSeats.push(requestedSeatNumber);
    await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));

    // Get transaction timestamp and use it for ticket composite key.
    const txTimestamp = ctx.stub.getTxTimestamp();
    const timestamp = txTimestamp.seconds.low.toString();
    const bookingTime = new Date(txTimestamp.seconds.low * 1000).toISOString();
    const ticketCompositeKey = ctx.stub.createCompositeKey(ticketPrefix, [travelOptionId, customerId, timestamp]);
    const encodedKey = Buffer.from(ticketCompositeKey).toString('base64').toString('utf8');

    // Create the ticket using the requested seat number.
    const ticketData = {
        ticketId: ticketCompositeKey,
        travelOptionId,
        customerId,
        encodedKey,
        seatNumber: requestedSeatNumber,
        bookingTime,
        timestamp,
        pricePaid: dynamicPrice,

        status: 'PENDING_CONFIRMATION',
        confirmationCount: 0,
        pricingBreakdown: {
            basePrice: travelOptionData.basePrice,
            occupancyFactor: occupancyFactor,
            dynamicFactor: dynamicFactor,
            dynamicPrice: dynamicPrice
        }
    };

    await ctx.stub.putState(ticketCompositeKey, Buffer.from(JSON.stringify(ticketData)));
    customerData.bookings.push(ticketCompositeKey);
    await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));

    return ticketData;
}












    /**
     * Confirm a ticket by simulating additional block confirmations.
     * This function increments the ticket's confirmation count.
     * When the confirmation count reaches 2 or more, the ticket status is updated to "CONFIRMED".
     * @param {Context} ctx The transaction context.
     * @param {String} ticketId The ticket identifier.
     */
     /**
   * CONFIRM TICKET
   * Increments the confirmation count; when it reaches 2, status becomes "CONFIRMED".
   */
      /**
     * Confirm a ticket by simulating additional block confirmations.
     * Increments the confirmation count; when it reaches 2, status becomes "CONFIRMED".
     */
    async confirmTicket(ctx, ticketCompositeKey) {
        const ticketBytes = await ctx.stub.getState(ticketCompositeKey);
        if (!ticketBytes || ticketBytes.length === 0) {
          throw new Error('Ticket does not exist.');
        }
        let ticketData = JSON.parse(ticketBytes.toString());
        if (ticketData.status !== 'PENDING_CONFIRMATION') {
          throw new Error('Ticket is not pending confirmation.');
        }
        ticketData.confirmationCount += 1;
        if (ticketData.confirmationCount >= 1) {
          ticketData.status = 'CONFIRMED';
        }
        await ctx.stub.putState(ticketCompositeKey, Buffer.from(JSON.stringify(ticketData)));
        return ticketData;
    }



    /**
     * Cancel an existing ticket.
     * Refunds the customer if cancellation is made more than 2 days before departure.
     * @param {Context} ctx The transaction context.
     * @param {String} ticketId The ticket identifier.
     * @param {String} currentTimestamp ISO timestamp representing current time.
     */
    async cancelTicket(ctx, ticketId, currentTimestamp) {
        const customerId = ctx.clientIdentity.getID();
        const ticketKey = ticketId;
        const ticketBytes = await ctx.stub.getState(ticketKey);
        if (!ticketBytes || ticketBytes.length === 0) {
            throw new Error('Ticket does not exist.');
        }
        let ticketData = JSON.parse(ticketBytes.toString());
        if (ticketData.customerId !== customerId) {
            throw new Error('Not authorized to cancel this ticket.');
        }
        if (ticketData.status !== 'PENDING_CONFIRMATION' && ticketData.status !== 'CONFIRMED') {
            throw new Error('Ticket cannot be cancelled.');
        }

        const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [ticketData.travelOptionId]);
        const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
        let travelOptionData = JSON.parse(travelOptionBytes.toString());

        const departureTime = new Date(`${travelOptionData.departureDate}T${travelOptionData.departureTime}`);
        const currentTime = new Date(currentTimestamp);
        const msInTwoDays = 2 * 24 * 60 * 60 * 1000;
        const msInOneDays = 24 * 60 * 60 * 1000;
        let refundAmount = 0;
        if ((departureTime - currentTime) >= msInTwoDays) {
            refundAmount = ticketData.pricePaid;
        }
        else if((departureTime - currentTime) >= msInOneDays){
            refundAmount = 0.8 * ticketData.pricePaid;
        }
        
        ticketData.status = 'CANCELLED';
        await ctx.stub.putState(ticketKey, Buffer.from(JSON.stringify(ticketData)));

        travelOptionData.availableSeats += 1;
        // NEW: Remove the cancelled seat from bookedSeats
        if (travelOptionData.bookedSeats && Array.isArray(travelOptionData.bookedSeats)) {
            const index = travelOptionData.bookedSeats.indexOf(ticketData.seatNumber);
            if (index !== -1) {
                travelOptionData.bookedSeats.splice(index, 1);
            }
        }
        await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));


        const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
        const customerBytes = await ctx.stub.getState(customerKey);
        let customerData = JSON.parse(customerBytes.toString());
        if (refundAmount > 0) {
            customerData.balance += refundAmount;
            const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
            const providerBytes = await ctx.stub.getState(providerKey);
            let providerData = JSON.parse(providerBytes.toString());
            providerData.balance -= refundAmount;
            await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
        }
        await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));

        return ticketData;
    }

    /**
     * Reschedule an existing ticket.
     * Cancels the old ticket and books a new ticket for a different travel option.
     * A penalty of 10% is charged if rescheduling is within 2 days of departure.
     * @param {Context} ctx The transaction context.
     * @param {String} ticketId The existing ticket ID.
     * @param {String} newTravelOptionId The new travel option ID.
     * @param {String} currentTimestamp ISO timestamp representing current time.
     */
    /**
 * Reschedule an existing ticket.
 * - Cancels the old ticket (processing refund if cancelled > 2 days before departure)
 * - Books a new ticket for the new travel option at full base price.
 * - Returns the newly booked ticket.
 * @param {Context} ctx The transaction context.
 * @param {String} ticketId The existing ticket ID (Base64-encoded composite key).
 * @param {String} newTravelOptionId The new travel option identifier.
 * @param {String} currentTimestamp ISO timestamp representing current time.
 */
    async rescheduleTicket(ctx, encodedTicketId, newTravelOptionId, currentTimestamp, selectedSeat) {
    // Decode the old ticket composite key
    const ticketBytes = await ctx.stub.getState(encodedTicketId);
    if (!ticketBytes || ticketBytes.length === 0) {
        throw new Error('Ticket does not exist.');
    }
    let oldTicket = JSON.parse(ticketBytes.toString());
    if (oldTicket.status !== 'PENDING_CONFIRMATION' && oldTicket.status !== 'CONFIRMED') {
        throw new Error('Only active tickets can be rescheduled.');
    }

    // Retrieve old travel option details
    const oldTravelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [oldTicket.travelOptionId]);
    const oldTravelOptionBytes = await ctx.stub.getState(oldTravelOptionKey);
    if (!oldTravelOptionBytes || oldTravelOptionBytes.length === 0) {
        throw new Error('Old travel option does not exist.');
    }
    let oldTravelOption = JSON.parse(oldTravelOptionBytes.toString());

    // Calculate refund amount using cancellation rules
    const departureTime = new Date(`${oldTravelOption.departureDate}T${oldTravelOption.departureTime}`);
    const currentTime = new Date(currentTimestamp);
    const msInTwoDays = 2 * 24 * 60 * 60 * 1000;
    const msInOneDay = 24 * 60 * 60 * 1000;
    let refundAmount = 0;
    if ((departureTime - currentTime) >= msInTwoDays) {
        refundAmount = oldTicket.pricePaid;
    } else if ((departureTime - currentTime) >= msInOneDay) {
        refundAmount = oldTicket.pricePaid * 0.8;
    }

    // Cancel the old ticket.
    oldTicket.status = 'CANCELLED';
    await ctx.stub.putState(encodedTicketId, Buffer.from(JSON.stringify(oldTicket)));

    // Increment available seats in the old travel option and remove the old seat from bookedSeats.
    oldTravelOption.availableSeats += 1;
    if (oldTravelOption.bookedSeats && Array.isArray(oldTravelOption.bookedSeats)) {
        const index = oldTravelOption.bookedSeats.indexOf(oldTicket.seatNumber);
        if (index !== -1) {
            oldTravelOption.bookedSeats.splice(index, 1);
        }
    }
    await ctx.stub.putState(oldTravelOptionKey, Buffer.from(JSON.stringify(oldTravelOption)));
    const providerKey = ctx.stub.createCompositeKey(providerPrefix, [oldTravelOption.providerId]);
    // Process refund: update customer and provider balances.
    /*
    const customerId = ctx.clientIdentity.getID();
    const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
    const customerBytes = await ctx.stub.getState(customerKey);
    let customerData = JSON.parse(customerBytes.toString());
    console.log(refundAmount);
    if (refundAmount > 0) {
        customerData.balance += refundAmount;
        const providerKey = ctx.stub.createCompositeKey(providerPrefix, [oldTravelOption.providerId]);
        const providerBytes = await ctx.stub.getState(providerKey);
        let providerData = JSON.parse(providerBytes.toString());
        providerData.balance -= refundAmount;
        await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
    }
    await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
    */
    
    
    
    // Book a new ticket for the new travel option using the selected seat.
    const newTicket = await this.bookTicket1(ctx, newTravelOptionId, selectedSeat, refundAmount, providerKey);

    // Record a reference to the old ticket in the new ticket.
    newTicket.rescheduledFrom = oldTicket.ticketId;
    await ctx.stub.putState(newTicket.ticketId, Buffer.from(JSON.stringify(newTicket)));

    return newTicket;
}

















    /**
     * Delete a travel option.
     * Allows a provider to remove a travel option if there are no active bookings.
     * @param {Context} ctx The transaction context.
     * @param {String} travelOptionId The travel option identifier.
     */
    async deleteTravelOption(ctx, travelOptionId) {
        const providerId = ctx.clientIdentity.getID();
        const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
        const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
        if (!travelOptionBytes || travelOptionBytes.length === 0) {
            throw new Error('Travel option does not exist.');
        }
        const travelOptionData = JSON.parse(travelOptionBytes.toString());
        if (travelOptionData.providerId !== providerId) {
            throw new Error('Not authorized to delete this travel option.');
        }
        if (travelOptionData.availableSeats !== travelOptionData.seatCapacity) {
            throw new Error('Cannot delete travel option with active bookings.');
        }
        await ctx.stub.deleteState(travelOptionKey);
        return { message: 'Travel option deleted successfully.' };
    }

    /**
     * Provider cancels an existing travel listing.
     * Refunds all active bookings and marks the travel option as cancelled.
     * @param {Context} ctx The transaction context.
     * @param {String} travelOptionId The travel option identifier.
     */
    async cancelTravelListing(ctx, travelOptionId) {
    const providerId = ctx.clientIdentity.getID();
    const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
    const travelOptionBytes = await ctx.stub.getState(travelOptionKey);

    if (!travelOptionBytes || travelOptionBytes.length === 0) {
        throw new Error('Travel option does not exist.');
    }

    let travelOptionData = JSON.parse(travelOptionBytes.toString());
    if (travelOptionData.providerId !== providerId) {
        throw new Error('Not authorized to cancel this travel option.');
    }

    const iterator = await ctx.stub.getStateByPartialCompositeKey(ticketPrefix, [travelOptionId]);
    
    // Fetch provider data **once**, after processing all tickets
    // const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
    // const providerBytes = await ctx.stub.getState(providerKey);
    // let providerData = JSON.parse(providerBytes.toString());
    
    
    
    let ticketsToCancel = [];
    let totalRefund = 0; // Track total refund amount

    while (true) {
        const res = await iterator.next();
        if (res.value && res.value.value.toString()) {
            let ticket = JSON.parse(res.value.value.toString('utf8'));
            if (ticket.status === 'PENDING_CONFIRMATION' || ticket.status === 'CONFIRMED') {
                ticketsToCancel.push({ key: res.value.key, ticket });
                totalRefund += ticket.pricePaid; // Accumulate total refund amount
            }
        }
        if (res.done) {
            await iterator.close();
            break;
        }
    }

    for (const entry of ticketsToCancel) {
        let ticket = entry.ticket;
        const customerKey = ctx.stub.createCompositeKey(customerPrefix, [ticket.customerId]);
        const customerBytes = await ctx.stub.getState(customerKey);
        
        if (customerBytes && customerBytes.length > 0) {
            let customerData = JSON.parse(customerBytes.toString());
            customerData.balance += ticket.pricePaid; // Refund customer
            await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
        }

        ticket.status = 'CANCELLED';
        await ctx.stub.putState(entry.key, Buffer.from(JSON.stringify(ticket)));
    }
    
    
    const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
    const providerBytes = await ctx.stub.getState(providerKey);
    let providerData = JSON.parse(providerBytes.toString());
    providerData.balance -= totalRefund; // Deduct total refund amount from provider's balance
    await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));

    travelOptionData.status = 'CANCELLED';
    travelOptionData.availableSeats = travelOptionData.seatCapacity;
    await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));

    return { message: `Travel listing cancelled, ${ticketsToCancel.length} bookings refunded, total refund: ${totalRefund}` };
}


    /**
     * Get all tickets booked by the invoking customer.
     * @param {Context} ctx The transaction context.
     */
    async getCustomerTickets(ctx) {
        const customerId = ctx.clientIdentity.getID();
        const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
        const customerBytes = await ctx.stub.getState(customerKey);
        if (!customerBytes || customerBytes.length === 0) {
            throw new Error('Customer not registered.');
        }
        const customerData = JSON.parse(customerBytes.toString());
        const tickets = [];
        for (const ticketKey of customerData.bookings) {
            const ticketBytes = await ctx.stub.getState(ticketKey);
            if (ticketBytes && ticketBytes.length > 0) {
                tickets.push(JSON.parse(ticketBytes.toString()));
            }
        }
        return tickets;
    }

    /**
     * Get details of the invoking customer.
     * @param {Context} ctx The transaction context.
     */
    async getCustomerDetails(ctx) {
        const customerId = ctx.clientIdentity.getID();
        const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
        const customerBytes = await ctx.stub.getState(customerKey);
        if (!customerBytes || customerBytes.length === 0) {
            throw new Error('Customer not registered.');
        }
        return customerBytes.toString();
    }

    /**
     * Get details of a specific ticket.
     * @param {Context} ctx The transaction context.
     * @param {String} ticketId The ticket identifier.
     */
    async getTicketDetails(ctx, encodedTicketId) {
        const compositeKey = encodedTicketId;
        //const compositeKey = Buffer.from(encodedTicketId, 'base64').toString('utf8');
        const ticketBytes = await ctx.stub.getState(compositeKey);
        if (!ticketBytes || ticketBytes.length === 0) {
            throw new Error('Ticket does not exist.');
        }
        return ticketBytes.toString();
}





async listTravelOptionsSorted1(ctx, source, destination, sortBy, minPrice, maxPrice, filterProviderId, onlyAvailable) {
        let options = await this.listTravelOptions(ctx, source, destination);
     
        // Filter by availability.
        if (onlyAvailable && onlyAvailable.toLowerCase() === 'true') {
            options = options.filter(opt => opt.availableSeats > 0);
        }
        // Filter by price range.
        if (minPrice) {
            options = options.filter(opt => parseFloat(opt.basePrice) >= parseFloat(minPrice));
        }
        if (maxPrice) {
            options = options.filter(opt => parseFloat(opt.basePrice) <= parseFloat(maxPrice));
        }
        // Filter by a specific provider.
        if (filterProviderId) {
            options = options.filter(opt => opt.serviceProvider === filterProviderId);
        }
        // Enrich options with provider rating if sorting by rating.
        if (sortBy === 'rating') {
            for (let i = 0; i < options.length; i++) {
                const providerKey = ctx.stub.createCompositeKey(providerPrefix, [options[i].providerId]);
                const providerBytes = await ctx.stub.getState(providerKey);
                if (providerBytes && providerBytes.length > 0) {
                    const providerData = JSON.parse(providerBytes.toString());
                    options[i].providerRating = providerData.rating;
                } else {
                    options[i].providerRating = 0;
                }
            }
        }
        if (sortBy === 'price') {
            options.sort((a, b) => a.basePrice - b.basePrice);
        } else if (sortBy === 'rating') {
            options.sort((a, b) => b.providerRating - a.providerRating);
        } else if (sortBy === 'transportMode') {
            options.sort((a, b) => a.transportMode.localeCompare(b.transportMode));
        }
        return options;
    }








    /**
     * Get all travel options registered by the invoking provider.
     * @param {Context} ctx The transaction context.
     */
    async getProviderTravelOptions(ctx) {
        const providerId = ctx.clientIdentity.getID();
        const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
        const providerBytes = await ctx.stub.getState(providerKey);
        if (!providerBytes || providerBytes.length === 0) {
            throw new Error('Provider not registered.');
        }
        let providerData = JSON.parse(providerBytes.toString());
        let travelOptions = [];
        for (const travelOptionId of providerData.travelOptions) {
            const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
            const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
            if (travelOptionBytes && travelOptionBytes.length > 0) {
                travelOptions.push(JSON.parse(travelOptionBytes.toString()));
            }
        }
        return travelOptions;
    }

    /**
     * Get provider details (including balance) for UI.
     * @param {Context} ctx The transaction context.
     */
    async getProviderDetails(ctx) {
        const providerId = ctx.clientIdentity.getID();
        const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
        const providerBytes = await ctx.stub.getState(providerKey);
        if (!providerBytes || providerBytes.length === 0) {
            throw new Error('Provider not registered.');
        }
        return providerBytes.toString();
    }

    /**
     * Rate a provider.
     * Allows a customer to rate the provider for a travel option after the travel date has passed.
     * The rating is averaged with previous ratings.
     * @param {Context} ctx The transaction context.
     * @param {String} ticketId The ticket identifier used to validate the travel.
     * @param {String} ratingStr The rating given by the customer (expected 0-5).
     * @param {String} currentTimestamp ISO timestamp representing current time.
     */
    async rateProvider(ctx, ticketId, ratingStr, currentTimestamp) {
        // Retrieve ticket to validate the travel.
        const ticketKey = ticketId;
        const ticketBytes = await ctx.stub.getState(ticketKey);
        if (!ticketBytes || ticketBytes.length === 0) {
            throw new Error('Ticket does not exist.');
        }
        const ticketData = JSON.parse(ticketBytes.toString());
        // Ensure the caller is the same as the ticket's customer.
        const customerId = ctx.clientIdentity.getID();
        if (ticketData.customerId !== customerId) {
            throw new Error('Not authorized to rate this provider.');
        }
        // Retrieve travel option to check travel date.
        const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [ticketData.travelOptionId]);
        const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
        if (!travelOptionBytes || travelOptionBytes.length === 0) {
            throw new Error('Travel option does not exist.');
        }
        const travelOptionData = JSON.parse(travelOptionBytes.toString());
        // Check that currentTimestamp is after travel date.
        const travelDateTime = new Date(`${travelOptionData.departureDate}T${travelOptionData.departureTime}`);
        const currentTime = new Date();
        if ((travelDateTime - currentTime) <= 1000) {
            throw new Error('Cannot rate provider before travel date.');
        }
        // Validate rating.
        const newRating = parseFloat(ratingStr);
        if (isNaN(newRating) || newRating < 0 || newRating > 5) {
            throw new Error('Rating must be a number between 0 and 5.');
        }
        // Retrieve provider details.
        const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
        const providerBytes = await ctx.stub.getState(providerKey);
        if (!providerBytes || providerBytes.length === 0) {
            throw new Error('Provider not registered.');
        }
        let providerData = JSON.parse(providerBytes.toString());
        // Compute new average rating.
        const currentNum = providerData.numRatings || 0;
        const currentAverage = providerData.rating || 0;
        const newAverage = ((currentAverage * currentNum) + newRating) / (currentNum + 1);
        providerData.rating = newAverage;
        providerData.numRatings = currentNum + 1;
        await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
        return providerData;
    }
    
    	/**
	 * Delete the customer account.
	 * Cancels all active tickets (PENDING_CONFIRMATION or CONFIRMED) and processes full refunds.
	 * Finally, deletes the customer record.
	 */
	async deleteCustomer(ctx) {
		const customerId = ctx.clientIdentity.getID();
		const customerKey = ctx.stub.createCompositeKey(customerPrefix, [customerId]);
		const customerBytes = await ctx.stub.getState(customerKey);
		if (!customerBytes || customerBytes.length === 0) {
			throw new Error('Customer not registered.');
		}
		let customerData = JSON.parse(customerBytes.toString());
		// Iterate over all ticket composite keys in customer bookings.
		for (const ticketKey of customerData.bookings) {
			const ticketBytes = await ctx.stub.getState(ticketKey);
			if (ticketBytes && ticketBytes.length > 0) {
				let ticketData = JSON.parse(ticketBytes.toString());
				// Cancel only if ticket is active.
				if (ticketData.status === 'PENDING_CONFIRMATION' || ticketData.status === 'CONFIRMED') {
					const refundAmount = ticketData.pricePaid;
					// Retrieve travel option details.
					const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [ticketData.travelOptionId]);
					const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
					if (travelOptionBytes && travelOptionBytes.length > 0) {
						let travelOptionData = JSON.parse(travelOptionBytes.toString());
						// Increase available seats.
						travelOptionData.availableSeats += 1;
						await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));
						// Deduct refund from provider.
						const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
						const providerBytes = await ctx.stub.getState(providerKey);
						if (providerBytes && providerBytes.length > 0) {
							let providerData = JSON.parse(providerBytes.toString());
							providerData.balance -= refundAmount;
							await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));
						}
					}
					// Mark the ticket as cancelled.
					ticketData.status = 'CANCELLED';
					await ctx.stub.putState(ticketKey, Buffer.from(JSON.stringify(ticketData)));
				}
			}
		}
		// Delete the customer record.
		await ctx.stub.deleteState(customerKey);
		return { message: 'Customer account deleted and all active tickets cancelled with refunds processed.' };
	}

	/**
	 * Delete the provider account.
	 * Cancels all travel options and, for each, cancels active bookings (with full refunds).
	 * Finally, deletes the provider record.
	 */
	async deleteProvider(ctx) {
		const providerId = ctx.clientIdentity.getID();
		const providerKey = ctx.stub.createCompositeKey(providerPrefix, [providerId]);
		const providerBytes = await ctx.stub.getState(providerKey);
		if (!providerBytes || providerBytes.length === 0) {
			throw new Error('Provider not registered.');
		}
		let providerData = JSON.parse(providerBytes.toString());
		// For each travel option of this provider.
		for (const travelOptionId of providerData.travelOptions) {
			const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
			const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
			if (travelOptionBytes && travelOptionBytes.length > 0) {
				let travelOptionData = JSON.parse(travelOptionBytes.toString());
				// Cancel active bookings for this travel option.
				const iterator = await ctx.stub.getStateByPartialCompositeKey(ticketPrefix, [travelOptionId]);
				while (true) {
					const res = await iterator.next();
					if (res.value && res.value.value.toString()) {
						let ticket = JSON.parse(res.value.value.toString('utf8'));
						if (ticket.status === 'PENDING_CONFIRMATION' || ticket.status === 'CONFIRMED') {
							const refundAmount = ticket.pricePaid;
							// Refund the customer.
							const customerKey = ctx.stub.createCompositeKey(customerPrefix, [ticket.customerId]);
							const customerBytes = await ctx.stub.getState(customerKey);
							if (customerBytes && customerBytes.length > 0) {
								let customerData = JSON.parse(customerBytes.toString());
								customerData.balance += refundAmount;
								await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));
							}
							// Deduct refund from provider.
							providerData.balance -= refundAmount;
							// Mark ticket as cancelled.
							ticket.status = 'CANCELLED';
							await ctx.stub.putState(res.value.key, Buffer.from(JSON.stringify(ticket)));
						}
					}
					if (res.done) {
						await iterator.close();
						break;
					}
				}
				// Mark travel option as cancelled.
				travelOptionData.status = 'CANCELLED';
				travelOptionData.availableSeats = travelOptionData.seatCapacity;
				await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));
			}
		}
		// Delete the provider record.
		await ctx.stub.deleteState(providerKey);
		return { message: 'Provider account deleted, all travel options cancelled and refunds processed.' };
	}
	
	
	/**
   * AUTO-CONFIRM TICKETS FOR A TRAVEL OPTION
   * If the current time is within 2 hours of departure, then:
   * - If pending tickets  available seats, confirm all pending tickets.
   * - If pending tickets > available seats, confirm the earliest pending tickets up to available seats,
   *   and cancel (with full refund) the rest.
   */
   /**
     * AUTO-CONFIRM TICKETS FOR A TRAVEL OPTION  
     * If the current time is within 2 hours of departure, then:
     * - If pending tickets  available seats, confirm all pending tickets.
     * - If pending tickets > available seats, confirm the earliest pending tickets up to available seats,
     *   and cancel (with full refund) the rest.
     */
    async autoConfirmTicketsForTravelOption(ctx, travelOptionId, currentTimestamp) {
      // Retrieve travel option.
      const travelOptionKey = ctx.stub.createCompositeKey(travelOptionPrefix, [travelOptionId]);
      const travelOptionBytes = await ctx.stub.getState(travelOptionKey);
      if (!travelOptionBytes || travelOptionBytes.length === 0) {
        throw new Error('Travel option does not exist.');
      }
      let travelOptionData = JSON.parse(travelOptionBytes.toString());

      const departureTime = new Date(`${travelOptionData.departureDate}T${travelOptionData.departureTime}`);
      const currentTime = new Date(currentTimestamp);
      const twoHoursMs = 2 * 60 * 60 * 1000;
      // Query pending tickets for this travel option.
      const iterator = await ctx.stub.getStateByPartialCompositeKey(ticketPrefix, [travelOptionId]);
      let pendingTickets = [];
      while (true) {
        const res = await iterator.next();
        if (res.value && res.value.value.toString()) {
          let ticket = JSON.parse(res.value.value.toString('utf8'));
          if (ticket.status === 'PENDING_CONFIRMATION') {
            pendingTickets.push(ticket);
          }
        }
        if (res.done) {
          await iterator.close();
          break;
        }
      }

      // Sort pending tickets by bookingTime (earliest first)
      pendingTickets.sort((a, b) => new Date(a.bookingTime) - new Date(b.bookingTime));

      const vacantSeats = travelOptionData.availableSeats;
      let confirmedCount = 0;
      let cancelledCount = 0;

      if (pendingTickets.length <= vacantSeats) {
        for (const ticket of pendingTickets) {
          ticket.status = 'CONFIRMED';
          ticket.confirmationCount = 2;
          await ctx.stub.putState(ticket.ticketId, Buffer.from(JSON.stringify(ticket)));
          confirmedCount++;
        }
        // travelOptionData.availableSeats -= pendingTickets.length;
        await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));
      } else {
        // Confirm only the earliest pending tickets up to vacantSeats.
        for (let i = 0; i < pendingTickets.length; i++) {
          let ticket = pendingTickets[i];
          if (i < vacantSeats) {
            ticket.status = 'CONFIRMED';
            ticket.confirmationCount = 2;
            await ctx.stub.putState(ticket.ticketId, Buffer.from(JSON.stringify(ticket)));
            confirmedCount++;
          } else {
            // Process full refund: update customer and provider balances.
            const customerKey = ctx.stub.createCompositeKey(customerPrefix, [ticket.customerId]);
            const customerBytes = await ctx.stub.getState(customerKey);
            let customerData = JSON.parse(customerBytes.toString());
            customerData.balance += ticket.pricePaid;
            await ctx.stub.putState(customerKey, Buffer.from(JSON.stringify(customerData)));

            const providerKey = ctx.stub.createCompositeKey(providerPrefix, [travelOptionData.providerId]);
            const providerBytes = await ctx.stub.getState(providerKey);
            let providerData = JSON.parse(providerBytes.toString());
            providerData.balance -= ticket.pricePaid;
            await ctx.stub.putState(providerKey, Buffer.from(JSON.stringify(providerData)));

            ticket.status = 'CANCELLED';
            await ctx.stub.putState(ticket.ticketId, Buffer.from(JSON.stringify(ticket)));
            cancelledCount++;
          }
        }
        travelOptionData.availableSeats = 0;
        await ctx.stub.putState(travelOptionKey, Buffer.from(JSON.stringify(travelOptionData)));
      }

      return {
        message: `Auto-confirmed ${confirmedCount} ticket(s) and cancelled ${cancelledCount} ticket(s) for travel option ${travelOptionId}.`
      };
    }


  /**
   * GET ALL TRAVEL OPTIONS
   * Returns all travel options on the ledger.
   */
  async getAllTravelOptions(ctx) {
    const iterator = await ctx.stub.getStateByPartialCompositeKey(travelOptionPrefix, []);
    let travelOptions = [];
    while (true) {
      const res = await iterator.next();
      if (res.value && res.value.value.toString()) {
        travelOptions.push(JSON.parse(res.value.value.toString('utf8')));
      }
      if (res.done) {
        await iterator.close();
        break;
      }
    }
    return JSON.stringify(travelOptions);
  }
	
	
}

module.exports = TravelTicket;


The file 'enrollAdmin.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/enrollAdmin.js) contains:

'use strict';
const FabricCAServices = require('fabric-ca-client');
const { Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function enrollAdmin() {
	try {
    	// Load the network configuration
    	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    	// Create a new CA client for interacting with the CA.
    	const caInfo = ccp.certificateAuthorities['ca.org1.example.com'];
    	const caTLSCACerts = caInfo.tlsCACerts.pem;
    	const ca = new FabricCAServices(caInfo.url, { trustedRoots: caTLSCACerts, verify: false }, caInfo.caName);
    	// Create a new file system-based wallet for managing identities.
    	const walletPath = path.join(process.cwd(), 'wallet');
    	const wallet = await Wallets.newFileSystemWallet(walletPath);
    	console.log(`Wallet path: ${walletPath}`);
    	// Check to see if we've already enrolled the admin user.
    	const identity = await wallet.get('admin');
    	if (identity) {
        	console.log('An identity for the admin user "admin" already exists in the wallet');
        	return;
    	}
    	// Enroll the admin user, and import the new identity into the wallet.
    	const enrollment = await ca.enroll({ enrollmentID: 'admin', enrollmentSecret: 'adminpw' });
    	const x509Identity = {
        	credentials: {
            	certificate: enrollment.certificate,
            	privateKey: enrollment.key.toBytes(),
        	},
        	mspId: 'Org1MSP',
        	type: 'X.509',
    	};
    	await wallet.put('admin', x509Identity);
    	console.log('Successfully enrolled admin user "admin" and imported it into the wallet');
	} catch (error) {
    	console.error(`Failed to enroll admin user "admin": ${error.message}`);
    	process.exit(1);
	}
}

module.exports = enrollAdmin;






The file 'enrollAdminOrg2.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/enrollAdminOrg2.js) contains:

'use strict';
const FabricCAServices = require('fabric-ca-client');
const { Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function enrollAdminOrg2() {
	try {
    	// Load the network configuration for Org2.
    	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org2.example.com', 'connection-org2.json');
    	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    	// Create a new CA client for interacting with the CA for Org2.
    	const caInfo = ccp.certificateAuthorities['ca.org2.example.com'];
    	const caTLSCACerts = caInfo.tlsCACerts.pem;
    	const ca = new FabricCAServices(caInfo.url, { trustedRoots: caTLSCACerts, verify: false }, caInfo.caName);
    	// Create a new file system-based wallet for managing identities.
    	const walletPath = path.join(process.cwd(), 'wallet');
    	const wallet = await Wallets.newFileSystemWallet(walletPath);
    	console.log(`Wallet path: ${walletPath}`);
    	// Check to see if the admin user for Org2 is already enrolled.
    	const identity = await wallet.get('adminOrg2');
    	if (identity) {
        	console.log('An identity for the admin user "adminOrg2" already exists in the wallet');
        	return;
    	}
    	// Enroll the admin user for Org2, and import the new identity into the wallet.
    	const enrollment = await ca.enroll({ enrollmentID: 'admin', enrollmentSecret: 'adminpw' });
    	const x509Identity = {
        	credentials: {
            	certificate: enrollment.certificate,
            	privateKey: enrollment.key.toBytes(),
        	},
        	mspId: 'Org2MSP',
        	type: 'X.509',
    	};
    	await wallet.put('adminOrg2', x509Identity);
    	console.log('Successfully enrolled admin user "adminOrg2" and imported it into the wallet');
	} catch (error) {
    	console.error(`Failed to enroll admin user "adminOrg2": ${error.message}`);
    	process.exit(1);
	}
}

module.exports = enrollAdminOrg2;






The file 'getCustomerDetails.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/getCustomerDetails.js) contains:

'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function getCustomerDetails(userEmail) {
  try {
	if (!userEmail) {
    	throw new Error('User email parameter is required.');
	}
	// Load connection profile for Org1.
	const ccpPath = path.resolve(
  	__dirname,
  	'..',
  	'..',
  	'test-network',
  	'organizations',
  	'peerOrganizations',
  	'org1.example.com',
  	'connection-org1.json'
	);
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

	// Use a consistent wallet path.
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);

	// Debug: list wallet identities.
	const identities = await wallet.list();
	console.log('Wallet identities:', identities);

	// Check for the identity.
	const identity = await wallet.get(userEmail);
	if (!identity) {
  	throw new Error(`Identity not found in wallet: ${userEmail}`);
	}

	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: userEmail, discovery: { enabled: true, asLocalhost: true } });
	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');

	console.log('Evaluating transaction: getCustomerDetails');
	const result = await contract.evaluateTransaction('getCustomerDetails');
	console.log(`Transaction result: ${result.toString()}`);

	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to get customer details: ${error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 1) {
	console.log('Usage: node getCustomerDetails.js <userEmail>');
	process.exit(1);
  }
  getCustomerDetails(args[0]);
}

module.exports = getCustomerDetails;






The file 'getProviderDetails.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/getProviderDetails.js) contains:

'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function getProviderDetails(providerEmail) {
  try {
	if (!providerEmail) {
    	throw new Error('Provider email parameter is required.');
	}
	// Load connection profile.
	const ccpPath = path.resolve(
  	__dirname,
  	'..',
  	'..',
  	'test-network',
  	'organizations',
  	'peerOrganizations',
  	'org1.example.com',
  	'connection-org1.json'
	);
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

	// Use a consistent wallet path.
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);

	// Look up provider identity using providerEmail.
	const identity = await wallet.get(providerEmail);
	if (!identity) {
  	throw new Error(`An identity for the provider "${providerEmail}" does not exist in the wallet`);
	}

	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: providerEmail, discovery: { enabled: true, asLocalhost: true } });
	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');

	console.log('Evaluating transaction: getProviderDetails');
	const result = await contract.evaluateTransaction('getProviderDetails');
	console.log(`Transaction result: ${result.toString()}`);
	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to get provider details: ${error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 1) {
	console.log('Usage: node getProviderDetails.js <providerEmail>');
	process.exit(1);
  }
  getProviderDetails(args[0]);
}

module.exports = getProviderDetails;






The file 'registerUser.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/registerUser.js) contains:

/*
 * registerUser.js
 * Register a new user (appUser) for Org1.
 */
'use strict';
const { Wallets } = require('fabric-network');
const FabricCAServices = require('fabric-ca-client');
const fs = require('fs');
const path = require('path');
async function registerUser() {
	try {
		const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
		const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
		console.log(ccp);
		const caURL = ccp.certificateAuthorities['ca.org1.example.com'].url;
		const ca = new FabricCAServices(caURL);
		const walletPath = path.join(process.cwd(), 'wallet');
		console.log(walletPath);
		const wallet = await Wallets.newFileSystemWallet(walletPath);
		console.log(`Wallet path: ${walletPath}`);
		const userIdentity = await wallet.get('appUser');
		if (userIdentity) {
			console.log('An identity for the user "appUser" already exists in the wallet');
			return;
		}
		const adminIdentity = await wallet.get('admin');
		if (!adminIdentity) {
			console.log('An identity for the admin user "admin" does not exist in the wallet');
			console.log('Run the enrollAdmin.js application before retrying');
			return;
		}
		const provider = wallet.getProviderRegistry().getProvider(adminIdentity.type);
		const adminUser = await provider.getUserContext(adminIdentity, 'admin');
		const secret = await ca.register({
			affiliation: 'org1.department1',
			enrollmentID: 'appUser',
			role: 'client',
			attrs: [{ name: 'role', value: 'minter', ecert: true }]
		}, adminUser);
		const enrollment = await ca.enroll({
			enrollmentID: 'appUser',
			enrollmentSecret: secret,
			attr_reqs: [{ name: 'role', optional: false }]
		});
		const x509Identity = {
			credentials: {
				certificate: enrollment.certificate,
				privateKey: enrollment.key.toBytes(),
			},
			mspId: 'Org1MSP',
			type: 'X.509',
		};
		await wallet.put('appUser', x509Identity);
		console.log('Successfully registered and enrolled user "appUser" and imported it into the wallet');
	} catch (error) {
		console.error(`Failed to register user "appUser": ${error}`);
		process.exit(1);
	}
}
module.exports = registerUser;






The file 'registerUserOrg2.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/registerUserOrg2.js) contains:

/*
 * registerUserOrg2.js
 * Register a new user (appUserOrg2) for Org2.
 */
'use strict';
const { Wallets } = require('fabric-network');
const FabricCAServices = require('fabric-ca-client');
const fs = require('fs');
const path = require('path');

async function registerUserOrg2() {
	try {
		const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org2.example.com', 'connection-org2.json');
		const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
		const caURL = ccp.certificateAuthorities['ca.org2.example.com'].url;
		const ca = new FabricCAServices(caURL);
		const walletPath = path.join(process.cwd(), 'wallet');
		const wallet = await Wallets.newFileSystemWallet(walletPath);
		console.log(`Wallet path: ${walletPath}`);
		const userIdentity = await wallet.get('appUserOrg2');
		if (userIdentity) {
			console.log('An identity for the user "appUserOrg2" already exists in the wallet');
			return;
		}
		const adminIdentity = await wallet.get('adminOrg2');
		if (!adminIdentity) {
			console.log('An identity for the admin user "adminOrg2" does not exist in the wallet');
			console.log('Run the enrollAdminOrg2.js application before retrying');
			return;
		}
		const provider = wallet.getProviderRegistry().getProvider(adminIdentity.type);
		const adminUser = await provider.getUserContext(adminIdentity, 'adminOrg2');
		const secret = await ca.register({
			affiliation: 'org2.department1',
			enrollmentID: 'appUserOrg2',
			role: 'client',
			attrs: [{ name: 'role', value: 'minter', ecert: true }]
		}, adminUser);
		const enrollment = await ca.enroll({
			enrollmentID: 'appUserOrg2',
			enrollmentSecret: secret,
			attr_reqs: [{ name: 'role', optional: false }]
		});
		const x509Identity = {
			credentials: {
				certificate: enrollment.certificate,
				privateKey: enrollment.key.toBytes(),
			},
			mspId: 'Org2MSP',
			type: 'X.509',
		};
		await wallet.put('appUserOrg2', x509Identity);
		console.log('Successfully registered and enrolled user "appUserOrg2" and imported it into the wallet');
	} catch (error) {
		console.error(`Failed to register user "appUserOrg2": ${error}`);
		process.exit(1);
	}
}
module.exports = registerUserOrg2;






The file 'serverAddTravelOption.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverAddTravelOption.js) contains:

'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function addTravelOption(providerEmail, source, destination, departureDate, departureTime, transportMode, seatCapacity, basePrice) {
  try {
	if (!providerEmail || !source || !destination || !departureDate || !departureTime || !transportMode || !seatCapacity || !basePrice) {
    	throw new Error('Missing required parameters for adding a travel option.');
	}
	const ccpPath = path.resolve(
  	__dirname,
  	'..',
  	'..',
  	'test-network',
  	'organizations',
  	'peerOrganizations',
  	'org1.example.com',
  	'connection-org1.json'
	);
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);

	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: providerEmail, discovery: { enabled: true, asLocalhost: true } });

	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');

	console.log(`Submitting transaction: addTravelOption with args "${source}", "${destination}", "${departureDate}", "${departureTime}", "${transportMode}", "${seatCapacity}", "${basePrice}"`);
	const result = await contract.submitTransaction('addTravelOption', source, destination, departureDate, departureTime, transportMode, seatCapacity.toString(), basePrice.toString());
	console.log(`Transaction result: ${result.toString()}`);

	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to add travel option: ${error.response ? error.response.data : error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 8) {
	console.log('Usage: node serverAddTravelOption.js <providerEmail> <source> <destination> <departureDate> <departureTime> <transportMode> <seatCapacity> <basePrice>');
	process.exit(1);
  }
  addTravelOption(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
}

module.exports = addTravelOption;






The file 'serverBookTicket.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverBookTicket.js) contains:

/*
 * serverBookTicket.js
 * Book a ticket for a given travel option and add it to the pending registry.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');
const { addPendingTicket } = require('../../backend/pendingTicketRegistry'); // adjust the path as needed
const { common } = require('fabric-protos');

async function bookTicket(travelOptionId, seatnumber,identityEmail) {
  try {
    if (!travelOptionId) {
      throw new Error('Travel option ID is required for booking.');
    }
    if (!identityEmail) {
      throw new Error('Customer identity email is required for booking.');
    }
    if (!seatnumber) {
      throw new Error('Please provide a vaild seat number.');
    }
    
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });
    
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    
    console.log(`Submitting transaction: bookTicket with travelOptionId "${travelOptionId}" using identity "${identityEmail}"`);
    const resultBuffer = await contract.submitTransaction('bookTicket', travelOptionId, seatnumber);
    console.log(`Transaction result: ${resultBuffer.toString()}`);
    
    // Parse the returned ticket data
    const ticket = JSON.parse(resultBuffer.toString());
    
    // Query the blockchain height via qscc
    const qscc = network.getContract('qscc');
    const infoBuffer = await qscc.evaluateTransaction('GetChainInfo', 'mychannel');
    const blockchainInfo = common.BlockchainInfo.decode(infoBuffer);
    const currentHeight = parseInt(blockchainInfo.height.toString(), 10);
    // Assume the ticket was recorded in block (currentHeight - 1)
    const bookingBlock = currentHeight - 1;
    console.log(`Ticket booked at block ${bookingBlock}`);
    
    // Add this ticket to the pending registry
    addPendingTicket(ticket.ticketId, bookingBlock);
    
    await gateway.disconnect();
    return resultBuffer.toString();
  } catch (error) {
    console.error(`Failed to book ticket: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 2) {
    console.log('Usage: node serverBookTicket.js <travelOptionId> <identityEmail> <seatnumber>');
    process.exit(1);
  }
  bookTicket(args[0], args[1]).then(console.log).catch(console.error);
}

module.exports = bookTicket;



The file 'serverCancelTicket.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverCancelTicket.js) contains:

/*
 * serverCancelTicket.js
 * Cancel an existing ticket.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function cancelTicket(ticketId, currentTimestamp, identityEmail) {
  try {
    if (!ticketId || !currentTimestamp) {
      throw new Error('Ticket ID and current timestamp are required for cancellation.');
    }
    if (!identityEmail) {
      throw new Error('Customer identity email is required for cancellation.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
  
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
  
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });
  
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
  
    console.log(`Submitting transaction: cancelTicket with args "${ticketId}", "${currentTimestamp}" using identity "${identityEmail}"`);
    const result = await contract.submitTransaction('cancelTicket', ticketId, currentTimestamp);
    console.log(`Transaction has been submitted, result: ${result.toString()}`);
  
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to cancel ticket: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 3) {
    console.log('Usage: node serverCancelTicket.js <ticketId> <currentTimestamp> <identityEmail>');
    process.exit(1);
  }
  cancelTicket(args[0], args[1], args[2]);
}

module.exports = cancelTicket;






The file 'serverDeleteTravelOption.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverDeleteTravelOption.js) contains:

/*
 * serverDeleteTravelOption.js
 * Delete a travel option.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function deleteTravelOption(travelOptionId) {
	try {
    	if (!travelOptionId) {
        	throw new Error('Travel option ID is required for deletion.');
    	}
    	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    	const walletPath = path.join(process.cwd(), 'wallet');
    	const wallet = await Wallets.newFileSystemWallet(walletPath);

    	const gateway = new Gateway();
    	await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });

    	const network = await gateway.getNetwork('mychannel');
    	const contract = network.getContract('stake');

    	console.log(`Submitting transaction: deleteTravelOption with travelOptionId "${travelOptionId}"`);
    	const result = await contract.submitTransaction('deleteTravelOption', travelOptionId);
    	console.log(`Transaction has been submitted, result: ${result.toString()}`);

    	await gateway.disconnect();
    	return result.toString();
	} catch (error) {
    	console.error(`Failed to delete travel option: ${error.response ? error.response.data : error.message}`);
    	throw new Error(`Chaincode error: ${error.message}`);
	}
}

if (require.main === module) {
	const args = process.argv.slice(2);
	if (args.length < 1) {
    	console.log('Usage: node serverDeleteTravelOption.js <travelOptionId>');
    	process.exit(1);
	}
	deleteTravelOption(args[0]);
}

module.exports = deleteTravelOption;






The file 'serverConfirmTicket.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverConfirmTicket.js) contains:

/*
 * serverConfirmTicket.js
 * Confirm a ticket by simulating additional block confirmations.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function confirmTicket(ticketId) {
	try {
    	if (!ticketId) {
        	throw new Error('Ticket ID is required for confirmation.');
    	}
    	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
   	 
    	const walletPath = path.join(process.cwd(), 'wallet');
    	const wallet = await Wallets.newFileSystemWallet(walletPath);
   	 
    	const gateway = new Gateway();
    	await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
   	 
    	const network = await gateway.getNetwork('mychannel');
    	const contract = network.getContract('stake');
   	 
    	console.log(`Submitting transaction: confirmTicket with ticketId "${ticketId}"`);
    	const result = await contract.submitTransaction('confirmTicket', ticketId);
    	console.log(`Transaction has been submitted, result: ${result.toString()}`);
   	 
    	await gateway.disconnect();
    	return result.toString();
	} catch (error) {
    	console.error(`Failed to confirm ticket: ${error.response ? error.response.data : error.message}`);
    	throw new Error(`Chaincode error: ${error.message}`);
	}
}

if (require.main === module) {
	const args = process.argv.slice(2);
	if (args.length < 1) {
    	console.log('Usage: node serverConfirmTicket.js <ticketId>');
    	process.exit(1);
	}
	confirmTicket(args[0]);
}

module.exports = confirmTicket;






The file 'serverDepositFunds.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverDepositFunds.js) contains:

/*
 * serverDepositFunds.js
 * Deposit funds into the customer's wallet.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function depositFunds(amount, identityEmail) {
  try {
    if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
      throw new Error('A valid positive deposit amount is required.');
    }
    if (!identityEmail) {
      throw new Error('Identity email is required for deposit funds.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });

    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');

    console.log(`Submitting transaction: depositFunds with amount "${amount}" using identity "${identityEmail}"`);
    const result = await contract.submitTransaction('depositFunds', amount);
    console.log(`Transaction has been submitted, result: ${result.toString()}`);

    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to deposit funds: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 2) {
    console.log('Usage: node serverDepositFunds.js <amount> <identityEmail>');
    process.exit(1);
  }
  depositFunds(args[0], args[1]);
}

module.exports = depositFunds;






The file 'serverGetCustomerTickets.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverGetCustomerTickets.js) contains:

/*
 * serverGetCustomerTickets.js
 * Get all tickets booked by the customer.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function getCustomerTickets(userEmail) {
  try {
	if (!userEmail) {
    	throw new Error('Customer email parameter is required.');
	}
	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
 
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);
 
	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: userEmail, discovery: { enabled: true, asLocalhost: true } });
 
	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');
 
	console.log('Evaluating transaction: getCustomerTickets');
	const result = await contract.evaluateTransaction('getCustomerTickets');
	console.log(`Transaction result: ${result.toString()}`);
 
	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to get customer tickets: ${error.response ? error.response.data : error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 1) {
	console.log('Usage: node serverGetCustomerTickets.js <customerEmail>');
	process.exit(1);
  }
  getCustomerTickets(args[0]);
}

module.exports = getCustomerTickets;






The file 'serverGetProviderDetails.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverGetProviderDetails.js) contains:

// src/screens/ProviderHome.jsx
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProviderHome = () => {
  const navigate = useNavigate();
  const { userDetails: providerDetails } = useAuth();

  const handleUpdateProfile = () => {
    navigate('/updateProvider');
  };

  return (
    <div className="container provider-home">
      {providerDetails ? (
        <div className="provider-dashboard">
          <h2>Welcome, {providerDetails.name}</h2>
          <p><b>Balance:</b> {providerDetails.balance}</p>
          <div className="provider-actions">
            <button className="btn" onClick={() => navigate('/addTravelOption')}>Add Travel Option</button>
            <button className="btn" onClick={() => navigate('/providerTravelOptions')}>View My Options</button>
            <button className="btn" onClick={handleUpdateProfile}>Update Profile</button>
          </div>
        </div>
      ) : (
        <div className="inputDiv">
          <h2>Provider Not Registered</h2>
          <p>Please sign up from the registration page.</p>
          <button className="btn" onClick={() => navigate('/signup?role=provider')}>Go to Sign Up</button>
        </div>
      )}
    </div>
  );
};

export default ProviderHome;






The file 'serverGetProviderTravelOptions.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverGetProviderTravelOptions.js) contains:

/*
 * serverGetProviderTravelOptions.js
 * Get all travel options registered by the provider.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function getProviderTravelOptions(providerEmail) {
	try {
    	if (!providerEmail) {
        	throw new Error('Provider email parameter is required.');
    	}
    	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
   	 
    	const walletPath = path.join(process.cwd(), 'wallet');
    	const wallet = await Wallets.newFileSystemWallet(walletPath);
   	 
    	const gateway = new Gateway();
    	await gateway.connect(ccp, { wallet, identity: providerEmail, discovery: { enabled: true, asLocalhost: true } });
   	 
    	const network = await gateway.getNetwork('mychannel');
    	const contract = network.getContract('stake');
   	 
    	console.log('Evaluating transaction: getProviderTravelOptions');
    	const result = await contract.evaluateTransaction('getProviderTravelOptions');
    	console.log(`Transaction evaluated, result: ${result.toString()}`);
   	 
    	await gateway.disconnect();
    	return result.toString();
	} catch (error) {
    	console.error(`Failed to get provider travel options: ${error.response ? error.response.data : error.message}`);
    	throw new Error(`Chaincode error: ${error.message}`);
	}
}

if (require.main === module) {
	const args = process.argv.slice(2);
	if (args.length < 1) {
    	console.log('Usage: node serverGetProviderTravelOptions.js <providerEmail>');
    	process.exit(1);
	}
	getProviderTravelOptions(args[0]);
}

module.exports = getProviderTravelOptions;


The file 'serverGetTicketDetails.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverGetTicketDetails.js) contains:

/*
 * serverGetTicketDetails.js
 * Get details of a specific ticket.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function getTicketDetails(ticketId) {
  try {
	if (!ticketId) {
    	throw new Error('Ticket ID is required to get ticket details.');
	}
	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
 
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);
 
	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
 
	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');
 
	console.log(`Evaluating transaction: getTicketDetails with ticketId "${ticketId}"`);
	const result = await contract.evaluateTransaction('getTicketDetails', ticketId);
	console.log(`Transaction result: ${result.toString()}`);
 
	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to get ticket details: ${error.response ? error.response.data : error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 1) {
	console.log('Usage: node serverGetTicketDetails.js <ticketId>');
	process.exit(1);
  }
  getTicketDetails(args[0]);
}

module.exports = getTicketDetails;






The file 'serverListTravelOptions.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverListTravelOptions.js) contains:

/*
 * serverListTravelOptions.js
 * List travel options for a given source and destination.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function listTravelOptions(source, destination) {
  try {
	if (!source || !destination) {
    	throw new Error('Both source and destination are required.');
	}
	const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
 
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);
 
	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
 
	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');
 
	console.log(`Evaluating transaction: listTravelOptions with args "${source}", "${destination}"`);
	const result = await contract.evaluateTransaction('listTravelOptions', source, destination);
	console.log(`Transaction result: ${result.toString()}`);
 
	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to list travel options: ${error.response ? error.response.data : error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 2) {
	console.log('Usage: node serverListTravelOptions.js <source> <destination>');
	process.exit(1);
  }
  listTravelOptions(args[0], args[1]);
}

module.exports = listTravelOptions;






The file 'serverListTravelOptionsSorted.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverListTravelOptionsSorted.js) contains:

/*
 * serverListTravelOptionsSorted.js
 * List travel options for a given source and destination, sorted by criteria,
 * with optional filters for price range, provider, and availability.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function listTravelOptionsSorted(source, destination, inputDate, sortBy, minPrice, maxPrice, filterProviderId, onlyAvailable) {
  try {
    if (!source || !destination || !sortBy) {
      throw new Error('Source, destination and sortBy parameters are required.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    const gateway = new Gateway();
    // For sorted listing, we're using a fixed identity ("appUser") here.
    // (If needed, you can modify this to use a dynamic identity.)
    await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });

    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');

    console.log(`Evaluating transaction: listTravelOptionsSorted with args "${source}", "${destination}", "${sortBy}", "${minPrice}", "${maxPrice}", "${filterProviderId}", "${onlyAvailable}"`);
    const result = await contract.evaluateTransaction(
      'listTravelOptionsSorted',
      source,
      destination,
      inputDate,
      sortBy,
      minPrice || "",
      maxPrice || "",
      filterProviderId || "",
      onlyAvailable ? onlyAvailable.toString() : ""
    );
    console.log(`Transaction result: ${result.toString()}`);

    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to list sorted travel options: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 3) {
    console.log('Usage: node serverListTravelOptionsSorted.js <source> <destination> <sortBy> [minPrice] [maxPrice] [filterProviderId] [onlyAvailable]');
    process.exit(1);
  }
  listTravelOptionsSorted(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
}

module.exports = listTravelOptionsSorted;






The file 'serverRateProvider.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverRateProvider.js) contains:

/*
 * serverRateProvider.js
 * Rate a provider.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function rateProvider(ticketId, rating, currentTimestamp, identityEmail) {
  try {
    if (!ticketId || !rating || !currentTimestamp) {
      throw new Error('Ticket ID, rating, and current timestamp are required.');
    }
    if (!identityEmail) {
      throw new Error('Customer identity email is required for rating.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });

    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');

    console.log(`Submitting transaction: rateProvider with args "${ticketId}", "${rating}", "${currentTimestamp}" using identity "${identityEmail}"`);
    const result = await contract.submitTransaction('rateProvider', ticketId, rating.toString(), currentTimestamp);
    console.log(`Transaction has been submitted, result: ${result.toString()}`);

    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to rate provider: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 4) {
    console.log('Usage: node serverRateProvider.js <ticketId> <rating> <currentTimestamp> <identityEmail>');
    process.exit(1);
  }
  rateProvider(args[0], args[1], args[2], args[3]);
}

module.exports = rateProvider;






The file 'serverRegisterCustomer.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverRegisterCustomer.js) contains:

/*
 * serverRegisterCustomer.js
 * Register a new customer on the travel ticket platform.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function registerCustomer(name, contact) {
  try {
    const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
    
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    
    console.log(`Submitting transaction: registerCustomer with args "${name}", "${contact}"`);
    const result = await contract.submitTransaction('registerCustomer', name, contact);
    console.log(`Transaction has been submitted, result: ${result.toString()}`);
    
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to register customer: ${error}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 2) {
    console.log('Usage: node serverRegisterCustomer.js <name> <contact>');
    process.exit(1);
  }
  registerCustomer(args[0], args[1]);
}

module.exports = registerCustomer;






The file 'serverRegisterCustomerDynamic.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverRegisterCustomerDynamic.js) contains:

'use strict';
const { Wallets, Gateway } = require('fabric-network');
const FabricCAServices = require('fabric-ca-client');
const fs = require('fs');
const path = require('path');

async function registerCustomerDynamic({ enrollmentID, name, contact }) {
  try {
	if (!enrollmentID || !name || !contact) {
    	throw new Error('Enrollment ID, name, and contact are required for customer registration.');
	}
	// Load the connection profile for Org1.
	const ccpPath = path.resolve(
  	__dirname,
  	'..',
  	'..',
  	'test-network',
  	'organizations',
  	'peerOrganizations',
  	'org1.example.com',
  	'connection-org1.json'
	);
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

	// Create a new CA client.
	const caURL = ccp.certificateAuthorities['ca.org1.example.com'].url;
	const ca = new FabricCAServices(caURL);

	// Use a consistent wallet path.
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);

	// Check if the identity already exists.
	const existingIdentity = await wallet.get(enrollmentID);
	if (existingIdentity) {
  	throw new Error(`An identity for ${enrollmentID} already exists`);
	}

	// Get admin identity.
	const adminIdentity = await wallet.get('admin');
	if (!adminIdentity) {
  	throw new Error('Admin identity not found. Run enrollAdmin.js first.');
	}
	const provider = wallet.getProviderRegistry().getProvider(adminIdentity.type);
	const adminUser = await provider.getUserContext(adminIdentity, 'admin');

	// Register the new customer.
	const secret = await ca.register(
  	{
    	affiliation: 'org1.department1',
    	enrollmentID: enrollmentID,
    	role: 'client',
    	attrs: [
      	{ name: 'role', value: 'customer', ecert: true },
      	{ name: 'name', value: name, ecert: true },
      	{ name: 'contact', value: contact, ecert: true }
    	]
  	},
  	adminUser
	);

	// Enroll the new customer.
	const enrollment = await ca.enroll({
  	enrollmentID: enrollmentID,
  	enrollmentSecret: secret,
  	attr_reqs: [{ name: 'role', optional: false }]
	});
	const x509Identity = {
  	credentials: {
    	certificate: enrollment.certificate,
    	privateKey: enrollment.key.toBytes()
  	},
  	mspId: 'Org1MSP',
  	type: 'X.509'
	};

	// Store the new identity in the wallet (using the email).
	await wallet.put(enrollmentID, x509Identity);
	console.log(`Successfully enrolled identity for ${enrollmentID}`);

	// Now invoke the chaincode to register the customer.
	const gw = new Gateway();
	await gw.connect(ccp, {
  	wallet,
  	identity: enrollmentID,
  	discovery: { enabled: true, asLocalhost: true }
	});
	const network = await gw.getNetwork('mychannel');
	const contract = network.getContract('stake');

	console.log(`Submitting chaincode transaction: registerCustomer with args "${name}", "${contact}"`);
	const result = await contract.submitTransaction('registerCustomer', name, contact);
	console.log(`Chaincode transaction result: ${result.toString()}`);

	await gw.disconnect();

	return { enrollmentID, name, contact, chaincodeResult: result.toString() };
  } catch (error) {
	throw new Error(`Failed to register customer: ${error.response ? error.response.data : error.message}`);
  }
}

module.exports = registerCustomerDynamic;






The file 'serverRegisterProviderDynamic.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverRegisterProviderDynamic.js) contains:

'use strict';
const { Wallets, Gateway } = require('fabric-network');
const FabricCAServices = require('fabric-ca-client');
const fs = require('fs');
const path = require('path');

async function registerProviderDynamic({ enrollmentID, name, contact, rating, serviceProvider }) {
  try {
    if (!enrollmentID || !name || !contact || rating === undefined || !serviceProvider) {
      throw new Error('Enrollment ID, name, contact, rating, and service provider are required for provider registration.');
    }

    // Load the connection profile for Org1.
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    // Create a new CA client.
    const caURL = ccp.certificateAuthorities['ca.org1.example.com'].url;
    const ca = new FabricCAServices(caURL);

    // Use a consistent wallet path.
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    // Check if the provider identity already exists.
    const existingIdentity = await wallet.get(enrollmentID);
    if (existingIdentity) {
      throw new Error(`An identity for ${enrollmentID} already exists`);
    }

    // Get admin identity.
    const adminIdentity = await wallet.get('admin');
    if (!adminIdentity) {
      throw new Error('Admin identity not found. Run enrollAdmin.js first.');
    }
    const provider = wallet.getProviderRegistry().getProvider(adminIdentity.type);
    const adminUser = await provider.getUserContext(adminIdentity, 'admin');

    // Register the new provider.
    const secret = await ca.register(
      {
        affiliation: 'org1.department1',
        enrollmentID: enrollmentID,
        role: 'client',
        attrs: [
          { name: 'role', value: 'provider', ecert: true },
          { name: 'name', value: name, ecert: true },
          { name: 'contact', value: contact, ecert: true },
          { name: 'rating', value: rating.toString(), ecert: true },
          { name: 'serviceProvider', value: serviceProvider, ecert: true } // Added serviceProvider
        ]
      },
      adminUser
    );

    // Enroll the new provider.
    const enrollment = await ca.enroll({
      enrollmentID: enrollmentID,
      enrollmentSecret: secret,
      attr_reqs: [
        { name: 'role', optional: false },
        { name: 'serviceProvider', optional: false } // Ensure serviceProvider is included in attributes
      ]
    });
    const x509Identity = {
      credentials: {
        certificate: enrollment.certificate,
        privateKey: enrollment.key.toBytes()
      },
      mspId: 'Org1MSP',
      type: 'X.509'
    };

    // Store the new identity in the wallet (using the email).
    await wallet.put(enrollmentID, x509Identity);
    console.log(`Successfully enrolled identity for ${enrollmentID}`);

    // Now invoke the chaincode to register the provider.
    const gw = new Gateway();
    await gw.connect(ccp, {
      wallet,
      identity: enrollmentID,
      discovery: { enabled: true, asLocalhost: true }
    });
    const network = await gw.getNetwork('mychannel');
    const contract = network.getContract('stake');

    console.log(`Submitting chaincode transaction: registerProvider with args "${name}", "${contact}", "${rating}", "${serviceProvider}"`);
    const result = await contract.submitTransaction('registerProvider', name, contact, rating.toString(), serviceProvider); // Pass serviceProvider
    console.log(`Chaincode transaction result: ${result.toString()}`);

    await gw.disconnect();

    return { enrollmentID, name, contact, rating, serviceProvider, chaincodeResult: result.toString() };
  } catch (error) {
    throw new Error(`Failed to register provider: ${error.response ? error.response.data : error.message}`);
  }
}

module.exports = registerProviderDynamic;





The file 'serverRescheduleTicket.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverRescheduleTicket.js) contains:

/*
 * serverRescheduleTicket.js
 * Reschedule an existing ticket.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function rescheduleTicket(ticketId, newTravelOptionId, currentTimestamp, identityEmail, selectedSeat) {
  try {
    if (!ticketId || !newTravelOptionId || !currentTimestamp) {
      throw new Error('Ticket ID, new travel option ID, and current timestamp are required for rescheduling.');
    }
    if (!identityEmail) {
      throw new Error('Customer identity email is required for rescheduling.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });
    
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    
    console.log(`Submitting transaction: rescheduleTicket with args "${ticketId}", "${newTravelOptionId}", "${currentTimestamp}" using identity "${identityEmail}"`);
    const result = await contract.submitTransaction('rescheduleTicket', ticketId, newTravelOptionId, currentTimestamp, selectedSeat);
    console.log(`Transaction has been submitted, result: ${result.toString()}`);
    
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to reschedule ticket: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 4) {
    console.log('Usage: node serverRescheduleTicket.js <ticketId> <newTravelOptionId> <currentTimestamp> <identityEmail>');
    process.exit(1);
  }
  rescheduleTicket(args[0], args[1], args[2], args[3]);
}

module.exports = rescheduleTicket;






The file 'serverRegisterProvider.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverRegisterProvider.js) contains:

/*
 * serverRegisterProvider.js
 * Register a new service provider on the travel ticket platform.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function registerProvider(name, contact, rating) {
  try {
    const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
    
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    
    console.log(`Submitting transaction: registerProvider with args "${name}", "${contact}", "${rating}"`);
    const result = await contract.submitTransaction('registerProvider', name, contact, rating.toString());
    console.log(`Transaction has been submitted, result: ${result.toString()}`);
    
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to register provider: ${error}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 3) {
    console.log('Usage: node serverRegisterProvider.js <name> <contact> <rating>');
    process.exit(1);
  }
  registerProvider(args[0], args[1], args[2]);
}

module.exports = registerProvider;






The file 'serverCancelTravelListing.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverCancelTravelListing.js) contains:

/*
 * serverCancelTravelListing.js
 * Provider cancels a travel listing (refunds all active bookings).
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function cancelTravelListing(travelOptionId, identityEmail) {
  try {
    if (!travelOptionId) {
      throw new Error('Travel option ID is required to cancel a travel listing.');
    }
    if (!identityEmail) {
      throw new Error('Provider identity email is required.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });

    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');

    console.log(`Submitting transaction: cancelTravelListing with travelOptionId "${travelOptionId}" using identity "${identityEmail}"`);
    const result = await contract.submitTransaction('cancelTravelListing', travelOptionId);
    console.log(`Transaction has been submitted, result: ${result.toString()}`);

    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to cancel travel listing: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 2) {
    console.log('Usage: node serverCancelTravelListing.js <travelOptionId> <identityEmail>');
    process.exit(1);
  }
  cancelTravelListing(args[0], args[1]);
}

module.exports = cancelTravelListing;






The file 'serverUpdateCustomerDetails.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverUpdateCustomerDetails.js) contains:

/*
 * serverUpdateCustomerDetails.js
 * Update details for an existing customer.
 * Accepts newName, newContact, isAnonymous (true/false) and identityEmail.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function updateCustomerDetails(newName, newContact, isAnonymous, identityEmail) {
  try {
    if (!newName) {
      throw new Error('New name is required.');
    }
    if (!isAnonymous && !newContact) {
      throw new Error('New contact is required when profile is not anonymous.');
    }
    if (!identityEmail) {
      throw new Error('Identity email is required.');
    }
    const ccpPath = path.resolve(
      __dirname,
      '..',
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: identityEmail, discovery: { enabled: true, asLocalhost: true } });
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    console.log(
      `Submitting transaction: updateCustomerDetails with args "${newName}", "${newContact}", "${isAnonymous}" using identity "${identityEmail}"`
    );
    isAnonymous = isAnonymous === true || isAnonymous === 'true'; // convert to boolean
    const result = await contract.submitTransaction('updateCustomerDetails', newName, newContact, isAnonymous);
    console.log(`Transaction result: ${result.toString()}`);
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    console.error(`Failed to update customer details: ${error.response ? error.response.data : error.message}`);
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 4) {
    console.log('Usage: node serverUpdateCustomerDetails.js <newName> <newContact> <isAnonymous> <identityEmail>');
    process.exit(1);
  }
  updateCustomerDetails(args[0], args[1], args[2], args[3]);
}

module.exports = updateCustomerDetails;



The file 'serverUpdateProviderDetails.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverUpdateProviderDetails.js) contains:

'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function updateProviderDetails(providerEmail, newName, newContact, newRating, isAnonymous) {
  try {
	if (!providerEmail) {
    	throw new Error('Provider email is required.');
	}
	if (!newName) {
    	throw new Error('New name is required.');
	}
	// If not anonymous, contact must be provided.
	if (!isAnonymous && !newContact) {
    	throw new Error('New contact is required when profile is not anonymous.');
	}
	if (newRating === undefined) {
    	throw new Error('New rating is required.');
	}
	const ccpPath = path.resolve(
  	__dirname,
  	'..',
  	'..',
  	'test-network',
  	'organizations',
  	'peerOrganizations',
  	'org1.example.com',
  	'connection-org1.json'
	);
	const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
	const walletPath = path.join(process.cwd(), 'wallet');
	const wallet = await Wallets.newFileSystemWallet(walletPath);

	const gateway = new Gateway();
	await gateway.connect(ccp, { wallet, identity: providerEmail, discovery: { enabled: true, asLocalhost: true } });
	const network = await gateway.getNetwork('mychannel');
	const contract = network.getContract('stake');

	console.log(`Submitting transaction: updateProviderDetails with args "${newName}", "${newContact}", "${newRating}", "${isAnonymous}"`);
	const result = await contract.submitTransaction('updateProviderDetails', newName, newContact, newRating.toString(), isAnonymous.toString());
	console.log(`Transaction result: ${result.toString()}`);
	await gateway.disconnect();
	return result.toString();
  } catch (error) {
	console.error(`Failed to update provider details: ${error.response ? error.response.data : error.message}`);
	throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 5) {
	console.log('Usage: node serverUpdateProviderDetails.js <providerEmail> <newName> <newContact> <newRating> <isAnonymous>');
	process.exit(1);
  }
  updateProviderDetails(args[0], args[1], args[2], args[3], args[4]);
}

module.exports = updateProviderDetails;






The file 'serverGetAllTravelOptions.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverGetAllTravelOptions.js) contains:

/*
 * serverGetAllTravelOptions.js
 * Get all travel options from the ledger.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function getAllTravelOptions() {
  try {
    const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations',
      'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    const gateway = new Gateway();
    // Use a fixed identity (e.g. "appUser") with permissions.
    await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    const result = await contract.evaluateTransaction('getAllTravelOptions');
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  getAllTravelOptions().then(console.log).catch(console.error);
}

module.exports = getAllTravelOptions;



The file 'serverAutoConfirmTickets.js' (Path: /home/vboxuser/sec-try/fabric-samples/sdk/javascript/serverAutoConfirmTickets.js) contains:

/*
 * serverAutoConfirmTickets.js
 * Auto-confirm tickets for a travel option that is within 2 hours of departure.
 */
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

async function autoConfirmTickets(travelOptionId, currentTimestamp, identityEmail) {
  try {
    if (!travelOptionId || !currentTimestamp || !identityEmail) {
      throw new Error('Travel option ID, current timestamp, and identity email are required.');
    }
    const ccpPath = path.resolve(__dirname, '..', '..', 'test-network', 'organizations',
      'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    const result = await contract.submitTransaction('autoConfirmTicketsForTravelOption', travelOptionId, currentTimestamp);
    await gateway.disconnect();
    return result.toString();
  } catch (error) {
    throw new Error(`Chaincode error: ${error.message}`);
  }
}

if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 3) {
    console.log('Usage: node serverAutoConfirmTickets.js <travelOptionId> <currentTimestamp> <identityEmail>');
    process.exit(1);
  }
  autoConfirmTickets(args[0], args[1], args[2]).then(console.log).catch(console.error);
}

module.exports = autoConfirmTickets;



The file 'server.js' (Path: /home/vboxuser/sec-try/fabric-samples/backend/server.js) contains:

'use strict';
require('dotenv').config();





const fs = require('fs');
const express = require('express');
const cors = require('cors');
const path = require('path');
const { Gateway, Wallets } = require('fabric-network');
const { admin, db } = require('./firebase'); 




// --------------------------
// Import SDK Endpoint Modules
// --------------------------
const enrollAdmin = require('../sdk/javascript/enrollAdmin');
// const enrollAdminOrg2 = require('../sdk/javascript/enrollAdminOrg2');
const getCustomerDetails = require('../sdk/javascript/getCustomerDetails');
const getProviderDetails = require('../sdk/javascript/getProviderDetails');
const depositFunds = require('../sdk/javascript/serverDepositFunds');
const getCustomerTickets = require('../sdk/javascript/serverGetCustomerTickets');
const getProviderTravelOptions = require('../sdk/javascript/serverGetProviderTravelOptions');
const getTicketDetails = require('../sdk/javascript/serverGetTicketDetails');
const listTravelOptions = require('../sdk/javascript/serverListTravelOptions');
const listTravelOptionsSorted = require('../sdk/javascript/serverListTravelOptionsSorted');
const rateProvider = require('../sdk/javascript/serverRateProvider');
const registerUser = require('../sdk/javascript/registerUser');
// const registerUserOrg2 = require('../sdk/javascript/registerUserOrg2');
const addTravelOption = require('../sdk/javascript/serverAddTravelOption');
const registerCustomerDynamic = require('../sdk/javascript/serverRegisterCustomerDynamic');
const registerProviderDynamic = require('../sdk/javascript/serverRegisterProviderDynamic');
const bookTicket = require('../sdk/javascript/serverBookTicket');
const cancelTicket = require('../sdk/javascript/serverCancelTicket');
const rescheduleTicket = require('../sdk/javascript/serverRescheduleTicket');
const cancelTravelListing = require('../sdk/javascript/serverCancelTravelListing');
const updateCustomerDetails = require('../sdk/javascript/serverUpdateCustomerDetails');
const confirmTicket = require('../sdk/javascript/serverConfirmTicket');
const updateProviderDetails = require('../sdk/javascript/serverUpdateProviderDetails');
const deleteTravelOption = require('../sdk/javascript/serverDeleteTravelOption');

const listTravelOptionsSorted1 = require('../sdk/javascript/serverListTravelOptionsSorted1');

// --------------------------
// Create Express App
// --------------------------
const app = express();
const port = process.env.PORT || 8000;

app.use(express.json());
app.use(cors({ origin: '*' }));

// --------------------------
// Authentication Router (e.g., Firebase Auth)
// --------------------------
const authRouter = require('/home/vboxuser/sec-try/fabric-samples/backend/routes/serverAuth');
app.use('/auth', authRouter);



// --------------------------
// Enrollment Endpoints
// --------------------------
app.get('/enrollall', async (req, res) => {
  try {
    console.log("Enroll all identities");
    await enrollAdmin();
    // await enrollAdminOrg2();
    await registerUser();
    // await registerUserOrg2();
    res.send({ success: true });
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// --------------------------
// Customer Endpoints
// --------------------------

// Dynamic customer registration
app.post('/registercustomer', async (req, res) => {
  try {
    const { name, contact, email } = req.body;
    if (!name || !contact || !email) {
      return res.status(400).send('Missing required fields: name, contact, and email');
    }
    console.log(`Registering customer with email: ${email}`);
    const ret = await registerCustomerDynamic({ enrollmentID: email, name, contact });
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Update customer details endpoint
app.post('/updatecustomerdetails', async (req, res) => {
  try {
    let { newName, newContact, isAnonymous } = req.body;
    isAnonymous = isAnonymous === true || isAnonymous === 'true'; // convert to boolean

    if (!newName) {
      return res.status(400).send('New name is required.');
    }
    if (!isAnonymous && !newContact) {
      return res.status(400).send('New contact is required when profile is not anonymous.');
    }
    // Expect the customer's email as a query parameter
    const userEmail = req.query.email;
    if (!userEmail) {
      return res.status(400).send('Email parameter is required');
    }
    const ret = await updateCustomerDetails(newName, newContact, isAnonymous, userEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});


// Get customer details
app.get('/getcustomerdetails', async (req, res) => {
  try {
    const userEmail = req.query.email;
    if (!userEmail) {
      return res.status(400).send('Email parameter is required');
    }
    const ret = await getCustomerDetails(userEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Deposit funds
app.post('/depositfunds', async (req, res) => {
  try {
    const { amount } = req.body;
    if (!amount) {
      return res.status(400).send('Amount is required.');
    }
    // Get identity from query parameter (or you could take it from the body)
    const identityEmail = req.query.email;
    if (!identityEmail) {
      return res.status(400).send('Email parameter is required for deposit.');
    }
    const ret = await depositFunds(amount, identityEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});




// Get customer tickets
app.get('/getcustomertickets', async (req, res) => {
  try {
    const userEmail = req.query.email;
    if (!userEmail) {
      return res.status(400).send('Email parameter is required');
    }
    const ret = await getCustomerTickets(userEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Book ticket
// Book ticket endpoint
app.post('/bookticket', async (req, res) => {
  try {
    const { travelOptionId, seatnumber } = req.body;
    if (!travelOptionId) {
      return res.status(400).send('Travel option ID is required.');
    }
    // Get customer identity (email) from the request body or query parameter.
    const identityEmail = req.body.email || req.query.email;
    if (!identityEmail) {
      return res.status(400).send('Email parameter is required for booking.');
    }
    const ret = await bookTicket(travelOptionId, seatnumber,identityEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});






// Cancel ticket
// Cancel ticket endpoint
app.post('/cancelticket', async (req, res) => {
  try {
    const { ticketId, currentTimestamp } = req.body;
    if (!ticketId || !currentTimestamp) {
      return res.status(400).send('Ticket ID and current timestamp are required.');
    }
    // Get the customer identity from request body or query (e.g., localStorage value from the client)
    const identityEmail = req.body.email || req.query.email;
    if (!identityEmail) {
      return res.status(400).send('Email parameter is required for cancelling a ticket.');
    }
    const ret = await cancelTicket(ticketId, currentTimestamp, identityEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});





// Reschedule ticket
app.post('/rescheduleticket', async (req, res) => {
  try {
    // Expect old ticket's encoded key, new travel option ID, and current timestamp in the request body
    const { ticketId, newTravelOptionId, currentTimestamp,  identityEmail, selectedSeat} = req.body;
    if (!ticketId || !newTravelOptionId || !currentTimestamp) {
      return res.status(400).send('Missing required fields.');
    }
    const ret = await rescheduleTicket(ticketId, newTravelOptionId, currentTimestamp,identityEmail, selectedSeat);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});



app.get('/listtraveloptionssorted1', async (req, res) => {
  try {
    const { source, destination, sortBy, minPrice, maxPrice, filterProviderId, onlyAvailable } = req.query;
    if (!source || !destination || !sortBy) {
      return res.status(400).send('Source, destination, and sortBy are required.');
    }
    const ret = await listTravelOptionsSorted1(
      source,
      destination,
      sortBy,
      minPrice || "",
      maxPrice || "",
      filterProviderId || "",
      onlyAvailable ? onlyAvailable.toString() : ""
    );
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});








// Confirm ticket
app.post('/confirmticket', async (req, res) => {
  try {
    const { ticketId } = req.body;
    if (!ticketId) {
      return res.status(400).send('Ticket ID is required.');
    }
    const ret = await confirmTicket(ticketId);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// --------------------------
// Provider Endpoints
// --------------------------

// Dynamic provider registration
app.post('/registerprovider', async (req, res) => {
  try {
    const { name, contact, rating, email, serviceProvider } = req.body;
    if (!name || !contact || rating === undefined || !email || !serviceProvider) {
      return res.status(400).send('Missing required fields: name, contact, rating, and email');
    }
    console.log(`Registering provider with email: ${email}`);
    const ret = await registerProviderDynamic({ enrollmentID: email, name, contact, rating, serviceProvider});
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Update provider details
app.post('/updateproviderdetails', async (req, res) => {
  try {
    const { providerEmail, newName, newContact, newRating, isAnonymous } = req.body;
    if (!providerEmail || !newName || (!isAnonymous && !newContact) || newRating === undefined) {
      return res.status(400).send('Missing required fields for provider update.');
    }
    console.log(`Updating provider details for ${providerEmail}: newName=${newName}, newContact=${newContact}, newRating=${newRating}, isAnonymous=${isAnonymous}`);
    const ret = await updateProviderDetails(providerEmail, newName, newContact, newRating, isAnonymous);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Add travel option
app.post('/addtraveloption', async (req, res) => {
  try {
    const { providerEmail, source, destination, departureDate, departureTime, transportMode, seatCapacity, basePrice } = req.body;
    if (!providerEmail || !source || !destination || !departureDate || !departureTime || !transportMode || !seatCapacity || !basePrice) {
      return res.status(400).send('Missing required fields for adding a travel option.');
    }
    console.log(`Adding travel option for provider ${providerEmail}: ${source} to ${destination}`);
    const ret = await addTravelOption(providerEmail, source, destination, departureDate, departureTime, transportMode, seatCapacity, basePrice);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Delete travel option
app.post('/deletetraveloption', async (req, res) => {
  try {
    const { travelOptionId } = req.body;
    if (!travelOptionId) {
      return res.status(400).send('Travel option ID is required.');
    }
    const ret = await deleteTravelOption(travelOptionId);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Cancel travel listing
app.post('/canceltravellisting', async (req, res) => {
  try {
    const { travelOptionId, providerEmail } = req.body;
    if (!travelOptionId) {
      return res.status(400).send('Travel option ID is required.');
    }
    // Check for provider email in body first; if not, fallback to query parameter.
    const identityEmail = providerEmail || req.query.email;
    if (!identityEmail) {
      return res.status(400).send('Provider email is required for cancelling travel listing.');
    }
    const ret = await cancelTravelListing(travelOptionId, identityEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});





// Get provider travel options
// Get provider travel options
app.get('/getprovidertraveloptions', async (req, res) => {
  try {
    const providerEmail = req.query.email;
    if (!providerEmail) {
      return res.status(400).send('Provider email parameter is required');
    }
    const ret = await getProviderTravelOptions(providerEmail);
    res.json(JSON.parse(ret));
  } catch (error) {
    res.status(500).send(error.toString());
  }
});





// Get provider details
app.get('/getproviderdetails', async (req, res) => {
  try {
    const providerEmail = req.query.email;
    if (!providerEmail) {
      return res.status(400).send('Provider email parameter is required');
    }
    const ret = await getProviderDetails(providerEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});



// --------------------------
// Listing and Ticket Endpoints
// --------------------------

// List travel options (unfiltered)
app.get('/listtraveloptions', async (req, res) => {
  try {
    const { source, destination } = req.query;
    if (!source || !destination) {
      return res.status(400).send('Source and destination are required.');
    }
    const ret = await listTravelOptions(source, destination);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// List travel options sorted with filters
// List travel options sorted with filters
app.get('/listtraveloptionssorted', async (req, res) => {
  try {
    const { source, destination, inputdate, sortBy, minPrice, maxPrice, filterProviderId, onlyAvailable } = req.query;
    if (!source || !destination || !inputdate || !sortBy) {
      return res.status(400).send('Source, destination, inputdate, and sortBy are required.');
    }
    const ret = await listTravelOptionsSorted(
      source,
      destination,
      inputdate,
      sortBy,
      minPrice || "",
      maxPrice || "",
      filterProviderId || "",
      onlyAvailable ? onlyAvailable.toString() : ""
    );
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});









// Rate provider
app.post('/rateprovider', async (req, res) => {
  try {
    const { ticketId, rating, currentTimestamp } = req.body;
    if (!ticketId || !rating || !currentTimestamp) {
      return res.status(400).send('Ticket ID, rating, and current timestamp are required.');
    }
    // Get customer identity (email) from body or query parameter.
    const identityEmail = req.body.email || req.query.email;
    if (!identityEmail) {
      return res.status(400).send('Email parameter is required for rating.');
    }
    const ret = await rateProvider(ticketId, rating, currentTimestamp, identityEmail);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});


const deleteCustomer = require('../sdk/javascript/serverDeleteCustomer');
const deleteProvider = require('../sdk/javascript/serverDeleteProvider');

// Endpoint to delete a customer account.
app.post('/deletecustomer', async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).send('Customer email is required.');
    
    // Invoke chaincode deletion.
    const chaincodeResult = await deleteCustomer(email);
    
    
    // Delete the customer document from Firestore.
    //await db.collection('customer').doc(email).delete();
    admin.auth().getUserByEmail(email).then((userRecord) => {
      // Retrieve the user's UID
      const userId = userRecord.uid;
  
      // Delete the user by UID
      return admin.auth().deleteUser(userId);
    }).then(() => {
      console.log("Successfully deleted user");
    }).catch((error) => {
      console.error("Error deleting user:", error);
    });
    
    console.log(`Customer identity ${email} removed from wallet.`);
  
    res.send({ chaincodeResult, message: 'Customer account deleted from blockchain and Firebase.' });
  } catch (error) {
    res.status(500).send(error.toString());
  }
});





// Endpoint to delete a provider account.
app.post('/deleteprovider', async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).send('Provider email is required.');
    
    // Invoke chaincode deletion.
    const chaincodeResult = await deleteProvider(email);
    
    // Delete the provider document from Firestore.
    //await db.collection('provider').doc(email).delete();
    admin.auth().getUserByEmail(email).then((userRecord) => {
      // Retrieve the user's UID
      const userId = userRecord.uid;
  
      // Delete the user by UID
      return admin.auth().deleteUser(userId);
    }).then(() => {
      console.log("Successfully deleted user");
    }).catch((error) => {
      console.error("Error deleting user:", error);
    });
  
    res.send({ chaincodeResult, message: 'Provider account deleted from blockchain and Firebase.' });
  } catch (error) {
    res.status(500).send(error.toString());
  }
});


// Get ticket details (by ticketId as URL parameter)
app.get('/getticketdetails', async (req, res) => {
  try {
    const ticketId = req.query.ticketId; // This is the encoded key
    console.log('Received Ticket ID:', ticketId);
    if (!ticketId) {
      return res.status(400).send('Ticket ID is required.');
    }
    const ret = await getTicketDetails(ticketId);
    res.send(ret);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});


const getAllTravelOptions = require('../sdk/javascript/serverGetAllTravelOptions');
const autoConfirmTickets = require('../sdk/javascript/serverAutoConfirmTickets');


const autoConfirmScheduler = require('./autoConfirmScheduler'); // Adjust the path if needed


// New endpoint: get all travel options.
app.get('/getalltraveloptions', async (req, res) => {
  try {
    const result = await getAllTravelOptions();
    res.send(result);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});

// Auto-confirm endpoint (unchanged)
app.post('/autoConfirmTickets', async (req, res) => {
  try {
    const { travelOptionId, currentTimestamp, identityEmail } = req.body;
    if (!travelOptionId || !currentTimestamp || !identityEmail) {
      return res.status(400).send('Travel option ID, current timestamp, and identity email are required.');
    }
    const result = await autoConfirmTickets(travelOptionId, currentTimestamp, identityEmail);
    res.send(result);
  } catch (error) {
    res.status(500).send(error.toString());
  }
});






// --------------------------
// Root Endpoint
// --------------------------
app.listen(port, () => {
  console.log(`Server listening at http://localhost:${port}`);

  // Fork the auto-confirm scheduler in a separate process
  const { fork } = require('child_process');
  const schedulerPath = path.join(__dirname, 'autoConfirmScheduler.js');
  fork(schedulerPath, [], { stdio: 'inherit', cwd: process.cwd() });
  console.log('Auto-confirm scheduler started.');

});





The file 'autoConfirmScheduler.js' (Path: /home/vboxuser/sec-try/fabric-samples/backend/autoConfirmScheduler.js) contains:

// autoConfirmScheduler.js
'use strict';
const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');
const { getPendingTickets, removePendingTicket } = require('./pendingTicketRegistry');
const { common } = require('fabric-protos');

// Existing function: get current block height
async function getCurrentBlockHeight(identity = 'appUser') {
  try {
    const ccpPath = path.resolve(
      __dirname,
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity, discovery: { enabled: true, asLocalhost: true } });
    const network = await gateway.getNetwork('mychannel');
    const qscc = network.getContract('qscc');
    const infoBuffer = await qscc.evaluateTransaction('GetChainInfo', 'mychannel');
    const blockchainInfo = common.BlockchainInfo.decode(infoBuffer);
    const height = parseInt(blockchainInfo.height.toString(), 10);
    await gateway.disconnect();
    return height;
  } catch (error) {
    console.error('Error getting current block height:', error);
    throw error;
  }
}

// Existing function: confirm a ticket
async function confirmTicket(ticketId, identity = 'appUser') {
  try {
    const ccpPath = path.resolve(
      __dirname,
      '..',
      'test-network',
      'organizations',
      'peerOrganizations',
      'org1.example.com',
      'connection-org1.json'
    );
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity, discovery: { enabled: true, asLocalhost: true } });
    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('stake');
    console.log(`Submitting transaction: confirmTicket for ticket ${ticketId}`);
    const result = await contract.submitTransaction('confirmTicket', ticketId);
    console.log(`Ticket confirmation result: ${result.toString()}`);
    await gateway.disconnect();
  } catch (error) {
    console.error(`Error confirming ticket ${ticketId}:`, error);
  }
}

// Existing blockbased check on pending tickets.
async function processPendingTickets() {
  try {
    const identity = 'appUser';
    const currentHeight = await getCurrentBlockHeight(identity);
    console.log(`Current block height: ${currentHeight}`);

    const pending = getPendingTickets();
    for (const [ticketId, bookingBlock] of Object.entries(pending)) {
      // Note: The threshold below (>= 2000) is as you have it.
      if (currentHeight - bookingBlock >= 2) {
        console.log(`Ticket ${ticketId} is eligible for confirmation (booked at block ${bookingBlock}).`);
        await confirmTicket(ticketId, identity);
        removePendingTicket(ticketId);
      } else {
        console.log(`Ticket ${ticketId} is not yet eligible (booked at block ${bookingBlock}).`);
      }
    }
  } catch (error) {
    console.error('Error processing pending tickets:', error);
  }
}

// NEW: Time-based check for travel options departing within 2 hours
async function processTimeBasedAutoConfirm() {
  try {
    // Require the function that returns all travel options.
    const getAllTravelOptions = require('../sdk/javascript/serverGetAllTravelOptions');
    const travelOptionsStr = await getAllTravelOptions();
    const travelOptions = JSON.parse(travelOptionsStr);
    const now = new Date();
    const twoHoursMs = 2 * 60 * 1000;

    for (const option of travelOptions) {
      // Construct a Date object for departure time.
      // Assumes option.departureDate and option.departureTime are in a format compatible with Date.
      const departureTime = new Date(`${option.departureDate}T${option.departureTime}`);
      const timeDiff = departureTime - now;
      console.log(timeDiff);
      if (timeDiff <= twoHoursMs) {
        console.log(`Travel option ${option.travelOptionId} is within 2 hours of departure.`);
        // Get current time as ISO string.
        const currentTimestamp = now.toISOString();
        // Call the chaincode function "autoConfirmTicketsForTravelOption" to trigger auto-confirmation.
        // Here we use a similar approach as confirmTicket.
        try {
          const ccpPath = path.resolve(
            __dirname,
            '..',
            'test-network',
            'organizations',
            'peerOrganizations',
            'org1.example.com',
            'connection-org1.json'
          );
          const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
          const walletPath = path.join(process.cwd(), 'wallet');
          const wallet = await Wallets.newFileSystemWallet(walletPath);
          const gateway = new Gateway();
          await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
          const network = await gateway.getNetwork('mychannel');
          const contract = network.getContract('stake');
          console.log(`Submitting auto-confirm for travel option ${option.travelOptionId} with current timestamp ${currentTimestamp}`);
          const result = await contract.submitTransaction('autoConfirmTicketsForTravelOption', option.travelOptionId, currentTimestamp);
          console.log(`Auto-confirm result for option ${option.travelOptionId}: ${result.toString()}`);
          await gateway.disconnect();
        } catch (err) {
          console.error(`Error auto-confirming tickets for option ${option.travelOptionId}:`, err);
        }
      } else {
        console.log(`Travel option ${option.travelOptionId} is not within 2 hours of departure.`);
      }
    }
  } catch (error) {
    console.error('Error processing time-based auto-confirmation:', error);
  }
}

// Combined scheduler: run both block-based and time-based checks.
async function scheduler() {
  await processPendingTickets();
  await processTimeBasedAutoConfirm();
}

// Run scheduler every minute.
setInterval(scheduler, 60 * 1000);

// If run directly, process once and exit.
if (require.main === module) {
  scheduler().then(() => process.exit(0)).catch(() => process.exit(1));
}

module.exports = {
  startBlockListener: processPendingTickets,
  addPendingTicket: (id, block) => {
    console.log(`Adding pending ticket ${id} booked in block ${block}`);
  }
};






The file 'blockEventListener.js' (Path: /home/vboxuser/sec-try/fabric-samples/backend/blockEventListener.js) contains:

// blockEventListener.js
'use strict';

const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

// In-memory pending ticket registry.
// Format: { ticketKey: bookingBlockNumber }
const pendingTickets = {};

// Threshold: number of blocks required for confirmation.
const CONFIRMATION_BLOCK_THRESHOLD = 2;

async function startBlockListener() {
  try {
    // Load connection profile.
    const ccpPath = path.resolve(__dirname, '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
    const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

    // Set up wallet and gateway using an identity (e.g., appUser).
    const walletPath = path.join(process.cwd(), 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);
    const gateway = new Gateway();
    await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });

    const network = await gateway.getNetwork('mychannel');

    // Listen for block events.
    console.log('Starting block event listener...');
    await network.addBlockListener(async (blockEvent) => {
      const blockNumber = blockEvent.blockNumber.low; // simple number for example
      console.log(`New block received: ${blockNumber}`);

      // For demonstration, assume that whenever a ticket is booked, another process adds its ticket key
      // and the current block number to our in-memory registry. Here, we simulate checking all pending tickets.
      for (const [ticketKey, bookingBlock] of Object.entries(pendingTickets)) {
        if ((blockNumber - bookingBlock) >= CONFIRMATION_BLOCK_THRESHOLD) {
          console.log(`Ticket ${ticketKey} has waited ${blockNumber - bookingBlock} blocks. Triggering confirmation...`);
          try {
            await confirmTicket(ticketKey);
            // Remove ticket from registry after confirmation.
            delete pendingTickets[ticketKey];
            console.log(`Ticket ${ticketKey} confirmed.`);
          } catch (err) {
            console.error(`Error confirming ticket ${ticketKey}:`, err);
          }
        }
      }
    });

  } catch (error) {
    console.error(`Error in block event listener: ${error.message}`);
  }
}

// Example function to simulate calling the confirmTicket endpoint directly.
async function confirmTicket(ticketKey) {
  // This function can use the serverConfirmTicket.js module (or similar) to submit the transaction.
  const { Gateway, Wallets } = require('fabric-network');
  const fs = require('fs');
  const path = require('path');

  const ccpPath = path.resolve(__dirname, '..', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
  const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));
  const walletPath = path.join(process.cwd(), 'wallet');
  const wallet = await Wallets.newFileSystemWallet(walletPath);
  const gateway = new Gateway();
  // Use "appUser" for example.
  await gateway.connect(ccp, { wallet, identity: 'appUser', discovery: { enabled: true, asLocalhost: true } });
  const network = await gateway.getNetwork('mychannel');
  const contract = network.getContract('stake');
  await contract.submitTransaction('confirmTicket', ticketKey);
  await gateway.disconnect();
}

// For demonstration purposes, simulate adding a ticket to the registry when booked.
// In your actual booking flow, when a ticket is successfully booked, add it to the registry.
function addPendingTicket(ticketKey, bookingBlockNumber) {
  pendingTickets[ticketKey] = bookingBlockNumber;
  console.log(`Added pending ticket ${ticketKey} booked in block ${bookingBlockNumber}`);
}

// Export the listener and helper functions.
module.exports = {
  startBlockListener,
  addPendingTicket
};

// If this file is run directly, start the listener.
if (require.main === module) {
  startBlockListener();
}



The file 'pendingTicketRegistry.js' (Path: /home/vboxuser/sec-try/fabric-samples/backend/pendingTicketRegistry.js) contains:

// pendingTicketRegistry.js
const fs = require('fs');
const path = require('path');

const registryPath = path.join(__dirname, 'pendingTickets.json');

function loadRegistry() {
  if (!fs.existsSync(registryPath)) {
    return {};
  }
  const data = fs.readFileSync(registryPath);
  return JSON.parse(data);
}

function saveRegistry(registry) {
  fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2));
}

function addPendingTicket(ticketId, blockNumber) {
  const registry = loadRegistry();
  registry[ticketId] = blockNumber;
  saveRegistry(registry);
}

function getPendingTickets() {
  return loadRegistry();
}

function removePendingTicket(ticketId) {
  const registry = loadRegistry();
  delete registry[ticketId];
  saveRegistry(registry);
}

module.exports = { addPendingTicket, getPendingTickets, removePendingTicket };




The file 'serverAuth.js' (Path: /home/vboxuser/sec-try/fabric-samples/backend/routes/serverAuth.js) contains:

'use strict';
require('dotenv').config();
const express = require('express');
const bcrypt = require('bcrypt');
const cors = require('cors');
const { admin, db } = require('../firebase'); 






const router = express.Router();

// Enable CORS and JSON parsing for our router.
router.use(cors({ origin: '*' }));
router.use(express.json());

// Helper function to create a new user record in Firestore.
async function createUser(role, { name, email, phone, password }) {
  const saltRounds = 10;
  const hashedPassword = await bcrypt.hash(password, saltRounds);
  // Use Firestore collection based on role.
  const user = { name, email, phone, password: hashedPassword };
  await db.collection(role).doc(email).set(user);
  return user;
}

// -------------------
// Customer Endpoints
// -------------------

// Signup endpoint for customers.
router.post('/signup/customer', async (req, res) => {
  try {
    const { name, email, phone, password } = req.body;
    if (!name || !email || !phone || !password) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    const userDoc = await db.collection('customer').doc(email).get();
    if (userDoc.exists) {
      return res.status(400).json({ error: 'Customer already exists' });
    }
    const user = await createUser('customer', { name, email, phone, password });
    return res.json({ message: 'Customer signed up successfully', user });
  } catch (error) {
    return res.status(500).json({ error: error.toString() });
  }
});

// Login endpoint for customers.
router.post('/login/customer', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }
    const userDoc = await db.collection('customer').doc(email).get();
    if (!userDoc.exists) {
      return res.status(400).json({ error: 'Customer not found' });
    }
    const user = userDoc.data();
    const passwordMatch = await bcrypt.compare(password, user.password);
    if (!passwordMatch) {
      return res.status(400).json({ error: 'Incorrect password' });
    }
    return res.json({ message: 'Customer login successful', user });
  } catch (error) {
    return res.status(500).json({ error: error.toString() });
  }
});

// -------------------
// Provider Endpoints
// -------------------

// Signup endpoint for providers.
router.post('/signup/provider', async (req, res) => {
  try {
    const { name, email, phone, password } = req.body;
    if (!name || !email || !phone || !password) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    const userDoc = await db.collection('provider').doc(email).get();
    if (userDoc.exists) {
      return res.status(400).json({ error: 'Provider already exists' });
    }
    const user = await createUser('provider', { name, email, phone, password });
    return res.json({ message: 'Provider signed up successfully', user });
  } catch (error) {
    return res.status(500).json({ error: error.toString() });
  }
});

// Login endpoint for providers.
router.post('/login/provider', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }
    const userDoc = await db.collection('provider').doc(email).get();
    if (!userDoc.exists) {
      return res.status(400).json({ error: 'Provider not found' });
    }
    const user = userDoc.data();
    const passwordMatch = await bcrypt.compare(password, user.password);
    if (!passwordMatch) {
      return res.status(400).json({ error: 'Incorrect password' });
    }
    return res.json({ message: 'Provider login successful', user });
  } catch (error) {
    return res.status(500).json({ error: error.toString() });
  }
});

module.exports = router;





The file 'App.js' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/App.js) contains:

// src/App.js
import './App.css';
import { Routes, Route, useNavigate } from 'react-router-dom';
import api from './api';
import { AuthProvider, useAuth } from './context/AuthContext';

import RoleSelection from './screens/RoleSelection';
import Login from './screens/Login';
import Signup from './screens/SignUp';
import UserHome from './screens/UserHome';
import ProviderHome from './screens/ProviderHome';
import SearchTravel from './screens/SearchTravel';
import MyTickets from './screens/MyTickets';
import DepositFunds from './screens/DepositFunds';
import AddTravelOption from './screens/AddTravelOption';
import ProviderTravelOptions from './screens/ProviderTravelOptions';
import RescheduleTicket from './screens/RescheduleTicket';
import RateProvider from './screens/RateProvider';
import PrintableTicket from './screens/PrintableTicket';
import TicketVerification from './screens/TicketVerification';
import UpdateCustomerDetails from './screens/UpdateCustomerDetails';
import UpdateProviderDetails from './screens/UpdateProviderDetails';
import DeleteAccount from './screens/DeleteAccount';

import RescheduleSeatSelection from './screens/RescheduleSeatSelection';

// Import your new SeatSelection component
import SeatSelection from './screens/SeatSelection';

import Navbar from './components/Navbar';
import ProtectedRoute from './components/ProtectedRoute';

function AppContent() {
  const navigate = useNavigate();
  const { role, setRole, status, setStatus, org, setOrg, updateUserDetails } = useAuth();

  const enrollAndRegister = async () => {
    try {
      const res = await api.get('/enrollall');
      console.log('Enroll response:', res.data);
      setStatus(true);
    } catch (error) {
      console.error('Enrollment error:', error.response?.data || error.message);
    }
  };

  const handleRoleSelect = (selectedRole) => {
    setRole(selectedRole);
    if (selectedRole === 'user') {
      setOrg('1'); // Customer: Org1
      navigate('/login?role=user');
    } else {
      setOrg('2'); // Provider: Org2
      navigate('/login?role=provider');
    }
  };

  return (
    <div className="App">
      {role && <Navbar />}
      <Routes>
        <Route
          path="/"
          element={
            <RoleSelection
              enrollAndRegister={enrollAndRegister}
              onRoleSelect={handleRoleSelect}
            />
          }
        />
        <Route path="/login" element={<Login />} />
        <Route path="/signup" element={<Signup />} />
        <Route
          path="/userhome"
          element={
            <ProtectedRoute roleRequired="user">
              <UserHome />
            </ProtectedRoute>
          }
        />
        <Route
          path="/searchTravel"
          element={
            <ProtectedRoute roleRequired="user">
              <SearchTravel />
            </ProtectedRoute>
          }
        />
        {/* New SeatSelection route added */}
        <Route
          path="/seatselection"
          element={
            <ProtectedRoute roleRequired="user">
              <SeatSelection />
            </ProtectedRoute>
          }
        />
        <Route
          path="/myTickets"
          element={
            <ProtectedRoute roleRequired="user">
              <MyTickets />
            </ProtectedRoute>
          }
        />
        <Route
          path="/depositFunds"
          element={
            <ProtectedRoute roleRequired="user">
              <DepositFunds />
            </ProtectedRoute>
          }
        />
        <Route
          path="/rescheduleticket"
          element={
            <ProtectedRoute roleRequired="user">
              <RescheduleTicket />
            </ProtectedRoute>
          }
        />
        <Route
          path="/rateprovider"
          element={
            <ProtectedRoute roleRequired="user">
              <RateProvider />
            </ProtectedRoute>
          }
        />
        <Route
          path="/printableTicket"
          element={
            <ProtectedRoute roleRequired="user">
              <PrintableTicket />
            </ProtectedRoute>
          }
        />
        <Route path="/ticketVerification" element={<TicketVerification />} />
        <Route
          path="/updateCustomer"
          element={
            <ProtectedRoute roleRequired="user">
              <UpdateCustomerDetails />
            </ProtectedRoute>
          }
        />
        <Route
          path="/providerhome"
          element={
            <ProtectedRoute roleRequired="provider">
              <ProviderHome />
            </ProtectedRoute>
          }
        />
        <Route
          path="/updateProvider"
          element={
            <ProtectedRoute roleRequired="provider">
              <UpdateProviderDetails />
            </ProtectedRoute>
          }
        />
        <Route
          path="/addTravelOption"
          element={
            <ProtectedRoute roleRequired="provider">
              <AddTravelOption />
            </ProtectedRoute>
          }
        />
        <Route
          path="/providerTravelOptions"
          element={
            <ProtectedRoute roleRequired="provider">
              <ProviderTravelOptions />
            </ProtectedRoute>
          }
        />
        <Route path="/deleteaccount" element={<DeleteAccount />} />
        <Route
          path="/reschedule-seat-selection"
          element={
            <ProtectedRoute roleRequired="user">
              <RescheduleSeatSelection />
    </ProtectedRoute>
  }
/>

        
      </Routes>
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <AppContent />
    </AuthProvider>
  );
}

export default App;






The file 'api.js' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/api.js) contains:

// src/api.js
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';

const api = axios.create({
  baseURL: API_BASE_URL,
});

export default api;






The file 'index.js' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/index.js) contains:

// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { BrowserRouter as Router } from "react-router-dom";
import { AuthProvider } from './context/AuthContext';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Router>
      <App />
    </Router>
  </React.StrictMode>
);

reportWebVitals();






The file 'App.css' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/App.css) contains:

/* src/App.css */
/* Global Styles */
body {
  background-color: #1a1a1a;
  color: #f5f5f5;
  margin: 0;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

/* Main Application Container */
.App {
  text-align: center;
  padding: 20px;
  margin: 0 auto;
}

/* Navbar Styles */
.navbar {
  background-color: #282c34;
  padding: 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  color: #fff;
  margin-bottom: 20px;
  border-radius: 8px;
}

.navbar h1 {
  margin: 0;
  font-size: 24px;
  cursor: pointer;
}

.nav-links a {
  color: #61dafb;
  margin: 0 10px;
  text-decoration: none;
}

.nav-links a:hover {
  text-decoration: underline;
}

/* Containers & Input Styles */
.inputDiv {
  margin: 1rem auto;
  max-width: 400px;
  text-align: left;
}

.inputField {
  padding: 10px;
  font-size: 16px;
  width: 100%;
  margin: 5px 0;
  border: 1px solid #ccc;
  border-radius: 4px;
}

/* Button Styles */
.btn {
  background-color: #4CAF50;
  border: none;
  color: #fff;
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  margin: 10px;
  border-radius: 6px;
  transition: background-color 0.3s ease, transform 0.2s;
  display: inline-block;
}

.btn:hover {
  background-color: #45a049;
  transform: translateY(-2px);
}

/* Add spacing between multiple buttons */
.button-group {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
  margin-top: 20px;
}

/* Details Container */
.detailsDiv {
  background-color: #333;
  padding: 15px;
  margin: 15px auto;
  max-width: 600px;
  text-align: left;
  border-radius: 6px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}

.detailsDiv b {
  color: #4CAF50;
}

/* Table Styles */
.table {
  margin-left: auto; 
  margin-right: auto;
  border-collapse: separate;
  border-spacing: 0;
  width: 90%;
  border-radius: 8px;
  overflow: hidden;
  background-color: #2a2a2a;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  text-align: center; 
}

.table th,
.table td {
  padding: 12px 15px;
  border-bottom: 1px solid #444;
  text-align: center;
}

.table th {
  background-color: #4CAF50;
  color: white;
}

.table tr:hover {
  background-color: #3b3b3b;
}

/* Specific Screen Containers */
.add-travel-option,
.deposit-funds,
.provider-travel-options {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center; /* This centers the child elements horizontally */
}
.reschedule-ticket {
  margin: 2rem auto;
  max-width: 600px;
  text-align: center;
}

/* Role Selection Screen */
.role-selection {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.role-buttons {
  margin-top: 20px;
}

/* Printable Ticket Styles */
.printable-ticket {
  border: 1px solid #444;
  padding: 20px;
  margin: 20px auto;
  max-width: 600px;
  background-color: #222;
  border-radius: 8px;
}

.printable-ticket .ticket-details {
  text-align: left;
  margin-bottom: 20px;
}

.printable-ticket .qr-code {
  margin: 20px auto;
}

/* Ticket Verification Styles */
.ticket-verification {
  padding: 20px;
  text-align: center;
}

/* Loader Styles */
.loader-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.spinner {
  border: 8px solid #f3f3f3;
  border-top: 8px solid #4CAF50;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive adjustments */
@media (max-width: 600px) {
  .inputDiv,
  .detailsDiv,
  .printable-ticket,
  .table {
    width: 95%;
  }

  .btn {
    width: 100%;
  }

  .button-group {
    flex-direction: column;
    gap: 10px;
  }
}


.search-form {
  background-color: #2a2a2a;
  padding: 30px;
  margin: 20px auto;
  border-radius: 12px;
  max-width: 600px;
  width: 90%;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
}

.search-form label {
  font-weight: bold;
  display: block;
  margin: 12px 0 6px;
}

.search-form input,
.search-form select {
  padding: 12px;
  font-size: 16px;
  width: 100%;
  border: 1px solid #666;
  border-radius: 6px;
  background-color: #1a1a1a;
  color: #f5f5f5;
  margin-bottom: 10px;
}

.search-form input[type="checkbox"] {
  width: auto;
  margin-left: 10px;
}


The file 'Loader.css' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/components/Loader.css) contains:



.loader-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.spinner {
  border: 8px solid #f3f3f3;
  border-top: 8px solid #4CAF50;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}






The file 'Loader.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/components/Loader.jsx) contains:

import React from 'react';
import './Loader.css';

const Loader = () => {
  return (
    <div className="loader-container">
      <div className="spinner"></div>
    </div>
  );
};

export default Loader;



The file 'Navbar.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/components/Navbar.jsx) contains:

// src/Navbar.jsx
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Navbar = () => {
  const navigate = useNavigate();
  const { role } = useAuth();

  return (
    <nav className="navbar">
      <h1 onClick={() => navigate('/')}>MyTravel.com</h1>
      <div className="nav-links">
        {role === 'user' ? (
          <>
            <Link to="/userhome">Home</Link>
            <Link to="/searchTravel">Search</Link>
            <Link to="/myTickets">Tickets</Link>
            <Link to="/depositFunds">Deposit</Link>
            <Link to="/updateCustomer">Update Profile</Link>
            <Link to="/ticketVerification">Verify Ticket</Link>
            <Link to="/deleteaccount">Delete Account</Link>

          </>
        ) : role === 'provider' ? (
          <>
            <Link to="/providerhome">Home</Link>
            <Link to="/addTravelOption">Add Option</Link>
            <Link to="/providerTravelOptions">My Options</Link>
            <Link to="/updateProvider">Update Profile</Link>
            <Link to="/ticketVerification">Verify Ticket</Link>
            <Link to="/deleteaccount">Delete Account</Link>
          </>
        ) : null}
      </div>
    </nav>
  );
};

export default Navbar;






The file 'ProtectedRoute.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/components/ProtectedRoute.jsx) contains:

// src/ProtectedRoute.jsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children, roleRequired }) => {
  const { userDetails, role, loading } = useAuth();

  

  if (!userDetails) {
    return <Navigate to={`/login?role=${roleRequired}`} />;
  }

  if (role !== roleRequired) {
    return <Navigate to="/login" />;
  }

  return children;
};

export default ProtectedRoute;






The file 'AuthContext.js' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/context/AuthContext.js) contains:

import React, { createContext, useContext, useState, useCallback } from 'react';
import api from '../api';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [role, setRole] = useState(null);
  const [userDetails, setUserDetails] = useState(null);
  const [status, setStatus] = useState(false);
  const [org, setOrg] = useState('');

  const updateUserDetails = useCallback(async (userEmailParam) => {
    const userEmail = userEmailParam || localStorage.getItem('userEmail');
    const providerEmail = userEmailParam || localStorage.getItem('providerEmail');

    if (!userEmail && !providerEmail) {
      console.error('No email provided for updateUserDetails.');
      return;
    }

    try {
      const endpoint = role === 'user' ? '/getcustomerdetails' : '/getproviderdetails';
      const res = await api.get(endpoint, { params: { email: role === 'user' ? userEmail : providerEmail } });

      console.log(endpoint);
      console.log(res);
      const user = typeof res.data === 'string' ? JSON.parse(res.data) : res.data;
      setUserDetails(user);
    } catch (error) {
      console.error('Update details error:', error.response?.data || error.message);
      setUserDetails(null);
    }
  }, [role]); 

  return (
    <AuthContext.Provider
      value={{
        role,
        setRole,
        userDetails,
        setUserDetails,
        status,
        setStatus,
        org,
        setOrg,
        updateUserDetails,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);



The file 'AddTravelOption.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/AddTravelOption.jsx) contains:

// src/screens/AddTravelOption.jsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';

const AddTravelOption = () => {
  const navigate = useNavigate();
  const [option, setOption] = useState({
    source: '',
    destination: '',
    departureDate: '',
    departureTime: '',
    transportMode: '',
    seatCapacity: '',
    basePrice: ''
  });

  const handleChange = (e) => {
    setOption({ ...option, [e.target.name]: e.target.value });
  };

  const handleSubmit = async () => {
    try {
      // Retrieve provider's email from localStorage.
      const providerEmail = localStorage.getItem('providerEmail');
      if (!providerEmail) {
        alert("Provider email not found. Please log in as a provider.");
        return;
      }
      // Include providerEmail in the payload
      const payload = { ...option, providerEmail };
      const res = await api.post('/addtraveloption', payload);
      console.log(res.data);
      alert("Travel option added successfully!");
      navigate('/providerTravelOptions');
    } catch (error) {
      console.error(error.response?.data || error.message);
      alert("Error booking ticket, same travel option already exists!");
    }
  };

  return (
    <div className="add-travel-option" style={{ textAlign: 'center', marginTop: '2rem' }}>
      <h2>Add Travel Option</h2>
      <h3>Disclaimer: 5rs will be charged on adding each travel options as a platform fees!</h3>
      <div className="inputDiv" style={{ display: 'inline-block', textAlign: 'left', margin: '1rem' }}>
        <label>Source:</label><br />
        <input type="text" name="source" value={option.source} onChange={handleChange} /><br />
        <label>Destination:</label><br />
        <input type="text" name="destination" value={option.destination} onChange={handleChange} /><br />
        <label>Departure Date:</label><br />
        <input type="date" name="departureDate" value={option.departureDate} onChange={handleChange} /><br />
        <label>Departure Time:</label><br />
        <input type="time" name="departureTime" value={option.departureTime} onChange={handleChange} /><br />
        <label>Transport Mode:</label><br />
        <input type="text" name="transportMode" value={option.transportMode} onChange={handleChange} placeholder="e.g., train, bus, plane" /><br />
        <label>Seat Capacity:</label><br />
        <input type="number" name="seatCapacity" value={option.seatCapacity} onChange={handleChange} /><br />
        <label>Base Price:</label><br />
        <input type="number" name="basePrice" value={option.basePrice} onChange={handleChange} /><br />
        <button className="btn" onClick={handleSubmit}>Add Option</button>
      </div>
      <button className="btn" onClick={() => navigate('/providerTravelOptions')}>Back to My Travel Options</button>
    </div>
  );
};

export default AddTravelOption;






The file 'DepositFunds.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/DepositFunds.jsx) contains:

// src/screens/DepositFunds.jsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';
import { useAuth } from '../context/AuthContext';

const DepositFunds = () => {
  const [amount, setAmount] = useState('');
  const navigate = useNavigate();
  const { updateUserDetails } = useAuth();

  const handleDeposit = async () => {
    try {
      // Retrieve the customer email from localStorage (set at login)
      const userEmail = localStorage.getItem('userEmail');
      if (!userEmail) {
        alert("Customer email not found. Please log in again.");
        return;
      }
      // Pass the email as a query parameter
      await api.post(`/depositfunds?email=${encodeURIComponent(userEmail)}`, { amount });
      alert("Funds deposited successfully!");
      await updateUserDetails(userEmail);
      navigate('/userhome');
    } catch (error) {
      console.error(error.response?.data || error.message);
      alert("Error depositing funds");
    }
  };

  return (
    <div className="container deposit-funds">
      <h2>Deposit Funds</h2>
      <div className="inputDiv">
        <label>Amount:</label><br />
        <input
          type="number"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
          className="inputField"
        /><br />
        <button className="btn" onClick={handleDeposit}>Deposit</button>
      </div>
      <button className="btn" onClick={() => navigate('/userhome')}>Back to Home</button>
    </div>
  );
};

export default DepositFunds;






The file 'Login.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/Login.jsx) contains:

import React, { useState, useEffect } from 'react'; // <- Ensure useEffect is imported
import { useLocation, useNavigate } from 'react-router-dom';
import { getAuth, signInWithEmailAndPassword } from 'firebase/auth';
import { app } from '../config/firebaseConfig';
import { useAuth } from '../context/AuthContext';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const { updateUserDetails, role, setRole } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const auth = getAuth(app);

  useEffect(() => {
    const query = new URLSearchParams(location.search);
    const roleParam = query.get('role');
    if (roleParam) {
      setRole(roleParam);
    }
  }, [location.search, setRole]);

  const handleLogin = async () => {
    setLoading(true);
    try {
      await signInWithEmailAndPassword(auth, email, password);
      localStorage.setItem(role === 'user' ? 'userEmail' : 'providerEmail', email);
      await updateUserDetails(email);
      setLoading(false);
      navigate(role === 'user' ? '/userhome' : '/providerhome');
    } catch (error) {
      setLoading(false);
      alert('Login failed: ' + error.message);
    }
  };

  return (
    <div className="container">
      <h2>Login as {role === 'user' ? 'Customer' : 'Provider'}</h2>
      <div className="inputDiv">
        <label>Email:</label>
        <br />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="inputField"
        />
        <br />
        <label>Password:</label>
        <br />
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="inputField"
        />
        <br />
        <button className="btn" onClick={handleLogin} disabled={loading}>
          {loading ? 'Logging in...' : 'Login'}
        </button>
      </div>
      <p>
        Don't have an account?{' '}
        <button className="link-btn" onClick={() => navigate('/signup?role=' + role)}>
          Sign Up
        </button>
      </p>
    </div>
  );
};

export default Login;






The file 'ProviderHome.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/ProviderHome.jsx) contains:

import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProviderHome = () => {
  const navigate = useNavigate();
  const { userDetails: providerDetails, updateUserDetails, role } = useAuth();

  useEffect(() => {
    const providerEmail = localStorage.getItem('providerEmail');
    if (role === 'provider' && providerEmail) {
      updateUserDetails(providerEmail);
    }
  }, [role, updateUserDetails]);

  const handleUpdateProfile = () => {
    navigate('/updateProvider');
  };

  return (
    <div className="container provider-home">
      {providerDetails ? (
        <div className="provider-dashboard">
          <h2>Welcome, {providerDetails.name}</h2>
          <p><b>Balance:</b> {providerDetails.balance}</p>
          <p><b>Your Rating:</b> {providerDetails.rating}</p>
          <p><b>Total number of customers rated:</b> {providerDetails.numRatings}</p>
          <div className="provider-actions">
            <button className="btn" onClick={() => navigate('/addTravelOption')}>
              Add Travel Option
            </button>
            <button className="btn" onClick={() => navigate('/providerTravelOptions')}>
              View My Options
            </button>
            <button className="btn" onClick={handleUpdateProfile}>
              Update Profile
            </button>
          </div>
        </div>
      ) : (
        <div className="inputDiv">
          <h2>Provider Not Registered</h2>
          <p>Please sign up from the registration page.</p>
          <button className="btn" onClick={() => navigate('/signup?role=provider')}>
            Go to Sign Up
          </button>
        </div>
      )}
    </div>
  );
};

export default ProviderHome;






The file 'ProviderTravelOptions.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/ProviderTravelOptions.jsx) contains:

import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';

const ProviderTravelOptions = () => {
    const [options, setOptions] = useState([]);
    const navigate = useNavigate();

    const fetchOptions = useCallback(async () => {
        try {
            const providerEmail = localStorage.getItem('providerEmail');
            if (!providerEmail) {
                console.error("No provider email found.");
                return;
            }

            const res = await api.get('/getprovidertraveloptions', {
                params: { email: providerEmail }
            });
            
            const filteredOptions = res.data.filter(option => option.status !== 'CANCELLED');
            setOptions(filteredOptions);
        } catch (error) {
            console.error('Error fetching travel options:', error.response?.data || error.message);
        }
    }, []);

    useEffect(() => {
        fetchOptions();
    }, [fetchOptions]);

    const handleCancelListing = async (travelOptionId) => {
        try {
            const providerEmail = localStorage.getItem('providerEmail');
            if (!providerEmail) {
                alert("Provider email not found. Please log in again.");
                return;
            }

            await api.post('/canceltravellisting', { travelOptionId, providerEmail });
            alert("Travel listing cancelled and refunds processed.");
            fetchOptions();
        } catch (error) {
            console.error('Cancel listing error:', error.response?.data || error.message);
            alert("Error cancelling travel listing");
        }
    };

    return (
        <div className="provider-travel-options">
            <h2>My Travel Options</h2>
            {options.length > 0 ? (
                <table className="table">
                    <thead>
                        <tr>
                            <th>Source</th>
                            <th>Destination</th>
                            <th>Departure</th>
                            <th>Mode</th>
                            <th>Service Provider</th>
                            <th>Available Seats</th>
                            <th>Base Price</th>
                            <th>Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        {options.map(option => (
                            <tr key={option.travelOptionId}>
                                <td>{option.source}</td>
                                <td>{option.destination}</td>
                                <td>{`${option.departureDate} ${option.departureTime}`}</td>
                                <td>{option.transportMode}</td>
                                <td>{option.serviceProvider}</td>
                                <td>{`${option.availableSeats} / ${option.seatCapacity}`}</td>
                                <td>{option.basePrice}</td>
                                <td>{option.status}</td>
                                <td>
                                    <button
                                        className="btn"
                                        onClick={() => handleCancelListing(option.travelOptionId)}
                                    >
                                        Cancel Listing
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            ) : (
                <p>No travel options found.</p>
            )}
            <div className="button-group">
                <button className="btn" onClick={() => navigate('/providerhome')}>
                    Back to Provider Home
                </button>
            </div>
        </div>
    );
};

export default ProviderTravelOptions;



The file 'RateProvider.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/RateProvider.jsx) contains:

import React, { useState, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import api from '../api';
import { useAuth } from '../context/AuthContext';

const RateProvider = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { ticketId } = location.state || {}; 
  const [rating, setRating] = useState(5);
  const { updateUserDetails } = useAuth();

  useEffect(() => {
    if (!ticketId) {
      alert("Invalid ticket details. Please try again.");
      navigate('/myTickets');
    }
  }, [ticketId, navigate]);

  const handleRate = async () => {
    try {
      const currentTimestamp = new Date().toISOString();
      const userEmail = localStorage.getItem('userEmail');
      if (!userEmail) {
        alert("User email not found. Please log in again.");
        return;
      }
      
      await api.post(`/rateprovider?email=${encodeURIComponent(userEmail)}`, { ticketId, rating, currentTimestamp });
      alert("Provider rated successfully!");
      await updateUserDetails(userEmail);
      navigate('/myTickets');
    } catch (error) {
      console.error(error.response?.data || error.message);
      alert("Error rating provider, cannot rate before travel time!");
    }
  };

  return (
    <div className="container rate-provider">
      <h2>Rate Provider</h2>
      <div className="inputDiv">
        <label>Rating (1-5):</label><br />
        <input type="number" min="1" max="5" value={rating} onChange={(e) => setRating(e.target.value)} className="inputField" /><br />
        <button className="btn" onClick={handleRate}>Submit Rating</button>
      </div>
      <button className="btn" onClick={() => navigate('/myTickets')}>Back to My Tickets</button>
    </div>
  );
};

export default RateProvider;



The file 'RescheduleTicket.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/RescheduleTicket.jsx) contains:

// src/screens/RescheduleTicket.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import api from '../api';

const RescheduleTicket = () => {
  const navigate = useNavigate();
  const location = useLocation();
  // Expect the old ticket to be passed via location.state
  const { oldTicket } = location.state || {};

  // Guard: if no ticket data, navigate back.
  useEffect(() => {
    if (!oldTicket || !oldTicket.travelOptionId) {
      alert('No ticket data available for rescheduling');
      navigate(-1);
    }
  }, [oldTicket, navigate]);

  const [options, setOptions] = useState([]);

  // Fetch alternative travel options based on the source, destination, and departure date extracted from the travelOptionId.
  useEffect(() => {
    if (oldTicket && oldTicket.travelOptionId) {
      // Assume travelOptionId format: "source_destination_departureDate_departureTime_providerId_timestamp"
      const parts = oldTicket.travelOptionId.split('_');
      if (parts.length < 4) {
        alert('Invalid travel option id format');
        navigate(-1);
        return;
      }
      const source = parts[0];
      const destination = parts[1];
      console.log(source, destination);
      const fetchOptions = async () => {
        try {
          const res = await api.get('/listtraveloptionssorted1', { 
            params: { 
              source, 
              destination,
              sortBy: 'price'
            } 
          });
          // Exclude the travel option that matches the old ticket.
          const filteredOptions = res.data.filter(option => option.travelOptionId !== oldTicket.travelOptionId);
          setOptions(filteredOptions);
        } catch (error) {
          console.error("Error fetching travel options:", error.response?.data || error.message);
        }
      };

      fetchOptions();
    }
  }, [oldTicket, navigate]);

  // When the user clicks "Reschedule to this Option", navigate to RescheduleSeatSelection page.
  const handleReschedule = (newTravelOption) => {
    navigate('/reschedule-seat-selection', { state: { oldTicket, newTravelOption } });
  };

  return (
    <div className="reschedule-ticket" style={{ textAlign: 'center', marginTop: '2rem' }}>
      <h2>Reschedule Ticket</h2>
      {options.length > 0 ? (
        <table style={{ margin: '0 auto', borderCollapse: 'collapse' }}>
          <thead>
            <tr>
              <th>Source</th>
              <th>Destination</th>
              <th>Departure</th>
              <th>Mode</th>
              <th>Price</th>
              <th>Available Seats</th>
              <th>Service Provider</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            {options.map(option => (
              <tr key={option.travelOptionId}>
                <td>{option.source}</td>
                <td>{option.destination}</td>
                <td>{option.departureDate} {option.departureTime}</td>
                <td>{option.transportMode}</td>
                <td>{option.basePrice}</td>
                <td>{option.availableSeats} / {option.seatCapacity}</td>
                <td>{option.serviceProvider}</td>
                <td>
                  <button className="btn" onClick={() => handleReschedule(option)}>
                    Reschedule to this Option
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      ) : (
        <p>No alternative travel options found.</p>
      )}
      <button className="btn" onClick={() => navigate(-1)}>Back</button>
    </div>
  );
};

export default RescheduleTicket;



The file 'RoleSelection.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/RoleSelection.jsx) contains:

// src/screens/RoleSelection.jsx
import React from 'react';
import { useNavigate } from 'react-router-dom';

const RoleSelection = ({ enrollAndRegister, onRoleSelect }) => {
  const navigate = useNavigate();

  const handleInitialize = () => {
    enrollAndRegister();
  };

  const handleUser = () => {
    onRoleSelect('user');
  };

  const handleProvider = () => {
    onRoleSelect('provider');
  };

  return (
    <div className="role-selection">
      <h1>Welcome to MyTravel.com</h1>
      <div className="role-buttons">
        <button className="btn" onClick={handleInitialize}>Initialize System</button>
        <button className="btn" onClick={handleUser}>Go in as User</button>
        <button className="btn" onClick={handleProvider}>Go in as Provider</button>
      </div>
    </div>
  );
};

export default RoleSelection;






The file 'SearchTravel.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/SearchTravel.jsx) contains:

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';
import { useAuth } from '../context/AuthContext';

const SearchTravel = () => {
  const [source, setSource] = useState('');
  const [destination, setDestination] = useState('');
  // Use departureDate to capture user input for date,
  // but send it under the key inputdate in the API request.
  const [departureDate, setDepartureDate] = useState(''); 
  const [sortBy, setSortBy] = useState('price');
  const [minPrice, setMinPrice] = useState('');
  const [maxPrice, setMaxPrice] = useState('');
  const [filterProviderId, setFilterProviderId] = useState('');
  const [onlyAvailable, setOnlyAvailable] = useState(false);
  const [travelOptions, setTravelOptions] = useState([]);
  const navigate = useNavigate();
  const { updateUserDetails } = useAuth();
  
  

  const handleSearch = async () => {
    try {
      const response = await api.get('/listtraveloptionssorted', {
        // Change departureDate key to "inputdate" to match backend expectation.
        params: { 
          source, 
          destination,
          inputdate: departureDate, 
          sortBy, 
          minPrice, 
          maxPrice, 
          filterProviderId, 
          onlyAvailable 
        }
      });
      
      // Filter out any cancelled travel options.
      const filteredOptions = response.data.filter(option => option.status !== 'CANCELLED');
      setTravelOptions(filteredOptions);
    } catch (error) {
      console.error('Error searching travel options:', error.response?.data || error.message);
    }
  };

  // Instead of booking the ticket directly, navigate to the SeatSelection page.
  const handleBook = (option) => {
    // It is assumed that the option object may contain bookedSeats; if not, we default to an empty array.
    const bookedSeats = option.bookedSeats || [];
    navigate('/seatselection', { state: { travelOption: option, bookedSeats } });
  };

  return (
    <div style={{ textAlign: 'center', marginTop: '2rem' }}>
      <h2>Search Travel Options</h2>
      <h3>Disclaimer: Extra 5rs will be charged on each ticket as a platform fees!</h3>
      <div className="inputDiv" style={{ display: 'inline-block', textAlign: 'left' }}>
        <label htmlFor="source">Source:</label><br />
        <input 
          type="text" 
          id="source" 
          value={source} 
          onChange={(e) => setSource(e.target.value)} 
        /><br />
        <label htmlFor="destination">Destination:</label><br />
        <input 
          type="text" 
          id="destination" 
          value={destination} 
          onChange={(e) => setDestination(e.target.value)} 
        /><br />
        <label htmlFor="departureDate">*Departure Date:</label><br />
        <input
          type="date"
          id="departureDate"
          value={departureDate}
          onChange={(e) => setDepartureDate(e.target.value)}
        /><br />
        <label htmlFor="sortBy">Sort By:</label><br />
        <select 
          id="sortBy" 
          value={sortBy} 
          onChange={(e) => setSortBy(e.target.value)}
        >
          <option value="price">Price</option>
          <option value="rating">Provider Rating</option>
          <option value="transportMode">Transport Mode</option>
        </select><br />
        <label htmlFor="minPrice">Min Price:</label><br />
        <input 
          type="number" 
          id="minPrice" 
          value={minPrice} 
          onChange={(e) => setMinPrice(e.target.value)} 
        /><br />
        <label htmlFor="maxPrice">Max Price:</label><br />
        <input 
          type="number" 
          id="maxPrice" 
          value={maxPrice} 
          onChange={(e) => setMaxPrice(e.target.value)} 
        /><br />
        <label htmlFor="filterProviderId">Service Provider:</label><br />
        <input
          type="text"
          id="filterProviderId"
          value={filterProviderId}
          onChange={(e) => setFilterProviderId(e.target.value)}
          placeholder="Enter Service Provider"
        /><br />
        <label htmlFor="onlyAvailable">Only Available:</label>
        <input
          type="checkbox"
          id="onlyAvailable"
          checked={onlyAvailable}
          onChange={(e) => setOnlyAvailable(e.target.checked)}
        /><br />
        <button className="btn" onClick={handleSearch}>Search</button>
      </div>
      {travelOptions && travelOptions.length > 0 ? (
        <table className="table">
          <thead>
            <tr>
              <th>Source</th>
              <th>Destination</th>
              <th>Departure</th>
              <th>Mode</th>
              <th>Price</th>
              <th>Available Seats</th>
              <th>Service Provider</th>
              <th>Rating</th>
              <th>Total Ratings</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            {travelOptions.map(option => (
              <tr key={option.travelOptionId}>
                <td>{option.source}</td>
                <td>{option.destination}</td>
                <td>{option.departureDate} {option.departureTime}</td>
                <td>{option.transportMode}</td>
                <td>{option.basePrice}</td>
                <td>{option.availableSeats} / {option.seatCapacity}</td>
                
                <td>{option.serviceProvider}</td>
                <td>{option.providerRating}</td>
                <td>{option.totalRating}</td>
                <td>
                  <button className="btn" onClick={() => handleBook(option)}>
                    Book Ticket
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      ) : (
        <p>No travel options found.</p>
      )}

      <button className="btn" onClick={() => navigate('/userhome')}>Back to Home</button>
    </div>
  );
};

export default SearchTravel;






The file 'SignUp.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/SignUp.jsx) contains:

import React, { useState, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { getAuth, createUserWithEmailAndPassword } from 'firebase/auth';
import { app } from '../config/firebaseConfig';
import { useAuth } from '../context/AuthContext';
import api from '../api';

const SignUp = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [contact, setContact] = useState('');
  const [gstin, setGstin] = useState('');
  const [serviceProvider, setServiceProvider] = useState(''); // New state for Service Provider
  const [isGstinVerified, setIsGstinVerified] = useState(false);
  const [captchaQuestion, setCaptchaQuestion] = useState('');
  const [captchaAnswer, setCaptchaAnswer] = useState('');
  const [userCaptchaAnswer, setUserCaptchaAnswer] = useState('');
  const [captchaError, setCaptchaError] = useState('');
  const location = useLocation();
  const navigate = useNavigate();
  const { role, setRole } = useAuth();
  const auth = getAuth(app);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const queryRole = params.get('role');
    if (!role && queryRole) {
      setRole(queryRole);
    }
    const a = Math.floor(Math.random() * 100) + 1;
    const b = Math.floor(Math.random() * 100) + 1;
    setCaptchaQuestion(`What is ${a} + ${b}?`);
    setCaptchaAnswer((a + b).toString());
  }, [location.search, role, setRole]);

  const handleVerifyGstin = () => {
    if (gstin.trim().length === 15) {
      // Simple validation for GSTIN (length check)
      setIsGstinVerified(true);
    } else {
      alert('Invalid GSTIN. Please enter a valid 15-character GSTIN.');
    }
  };

  const handleSignUp = async () => {
    if (role === 'provider' && !isGstinVerified) {
      alert('Please verify your GSTIN before signing up.');
      return;
    }
    if (userCaptchaAnswer.trim() !== captchaAnswer) {
      setCaptchaError('Captcha answer is incorrect.');
      return;
    }
    try {
      await createUserWithEmailAndPassword(auth, email, password);
      if (role === 'user') {
        await api.post('/registercustomer', { name, contact, email });
      } else {
        await api.post('/registerprovider', { name, contact, rating: 5, email, serviceProvider });
      }
      navigate('/login?role=' + role + '&email=' + encodeURIComponent(email));
    } catch (error) {
      alert('Signup failed: ' + (error.response?.data || error.message));
    }
  };

  return (
    <div className="container">
      <h2>Sign Up as {role === 'user' ? 'Customer' : 'Provider'}</h2>
      <div className="inputDiv">
        <label>Name:</label>
        <br />
        <input type="text" value={name} onChange={(e) => setName(e.target.value)} className="inputField" />
        <br />
        <label>Contact:</label>
        <br />
        <input type="text" value={contact} onChange={(e) => setContact(e.target.value)} className="inputField" />
        <br />
        <label>Email:</label>
        <br />
        <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="inputField" />
        <br />
        <label>Password:</label>
        <br />
        <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="inputField" />
        <br />
        {role === 'provider' && (
          <div>
            <label>GSTIN:</label>
            <br />
            <input type="text" value={gstin} onChange={(e) => setGstin(e.target.value)} className="inputField" />
            <button onClick={handleVerifyGstin}>Verify</button>
            {isGstinVerified && <p style={{ color: 'green', fontWeight: 'bold' }}>Verified!</p>}
            <br />
            <label>Service Provider:</label>
            <br />
            <input
              type="text"
              value={serviceProvider}
              onChange={(e) => setServiceProvider(e.target.value)}
              className="inputField"
            />
            <br />
          </div>
        )}
        <label>{captchaQuestion} (Captcha):</label>
        <br />
        <input
          type="text"
          value={userCaptchaAnswer}
          onChange={(e) => {
            setUserCaptchaAnswer(e.target.value);
            setCaptchaError('');
          }}
          className="inputField"
        />
        <br />
        {captchaError && <p style={{ color: 'red' }}>{captchaError}</p>}
        <button className="btn" onClick={handleSignUp}>Sign Up</button>
      </div>
    </div>
  );
};

export default SignUp;





The file 'UserHome.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/UserHome.jsx) contains:

// src/screens/UserHome.jsx
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const UserHome = () => {
  const navigate = useNavigate();
  const { userDetails, updateUserDetails, status, role } = useAuth();
  
  
  useEffect(() => {
    const userEmail = localStorage.getItem('userEmail');
    if (role === 'user' && userEmail) {
      updateUserDetails(userEmail);
    }
  }, [role, updateUserDetails]);


  const handleDeposit = () => {
    navigate('/depositFunds');
  };

  const handleUpdateProfile = () => {
    navigate('/updateCustomer');
  };

  return (
    <div className="container user-home">
      {userDetails ? (
        <div className="user-dashboard">
          <h2>Welcome, {userDetails.name}</h2>
          <p><b>Balance:</b> {userDetails.balance}</p>
          <div className="actions">
            <button className="btn" onClick={() => navigate('/searchTravel')}>Search Travel Options</button>
            <button className="btn" onClick={() => navigate('/myTickets')}>My Tickets</button>
            <button className="btn" onClick={handleDeposit}>Deposit Funds</button>
            <button className="btn" onClick={handleUpdateProfile}>Update Profile</button>
          </div>
        </div>
      ) : (
        <div className="inputDiv">
          <h2>User Not Registered</h2>
          <p>Please sign up from the registration page.</p>
          <button className="btn" onClick={() => navigate('/signup?role=user')}>Go to Sign Up</button>
        </div>
      )}
    </div>
  );
};

export default UserHome;






The file 'MyTickets.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/MyTickets.jsx) contains:

// src/screens/MyTickets.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';
import { useAuth } from '../context/AuthContext';

const MyTickets = () => {
  const [tickets, setTickets] = useState([]);
  const navigate = useNavigate();
  const { updateUserDetails } = useAuth();

  const fetchTickets = async () => {
    try {
      const response = await api.get('/getcustomertickets', { params: { email: localStorage.getItem('userEmail') } });
      setTickets(response.data);
    } catch (error) {
      console.error(error.response?.data || error.message);
    }
  };

  useEffect(() => {
    fetchTickets();
  }, []);

  const handleCancel = async (ticketId) => {
    try {
      const currentTimestamp = new Date().toISOString();
      // Retrieve the user email from localStorage
      const userEmail = localStorage.getItem('userEmail');
      if (!userEmail) {
        alert("User email not found. Please log in again.");
        return;
      }
      // Pass the email as a query parameter (or in the body)
      await api.post(`/cancelticket?email=${encodeURIComponent(userEmail)}`, { ticketId, currentTimestamp });
      await updateUserDetails(userEmail);
      fetchTickets();
      alert("Ticket cancelled successfully");
    } catch (error) {
      alert("Error cancelling ticket: " + (error.response?.data || error.message));
    }
  };

  // Updated: pass the entire ticket object instead of ticketId
  const handleReschedule = (ticket) => {
    navigate('/rescheduleticket', { state: { oldTicket: ticket } });
  };

  const handleRate = (ticketId) => {
    navigate('/rateprovider', { state: { ticketId } });
  };

  const handlePrint = (ticket) => {
    navigate('/printableTicket', { state: { ticket } });
  };

  return (
    <div className="container">
      <h2>My Tickets</h2>
      {tickets && tickets.length > 0 ? (
        tickets.map((ticket) => (
          <div key={ticket.ticketId} className="detailsDiv">
            <p><b>Seat Number:</b> {ticket.seatNumber}</p>
            <p><b>Booking Time:</b> {ticket.bookingTime}</p>
            <p><b>Status:</b> {ticket.status}</p>
            {(ticket.status === 'CONFIRMED' || ticket.status === 'PENDING_CONFIRMATION') && (
              <div>
                <button className="btn" onClick={() => handleCancel(ticket.ticketId)}>Cancel Ticket</button>
                {/* Pass the full ticket object to handleReschedule */}
                <button className="btn" onClick={() => handleReschedule(ticket)}>Reschedule Ticket</button>
              </div>
            )}
            {ticket.status === 'CONFIRMED' && new Date(ticket.bookingTime) < new Date() && (
              <button className="btn" onClick={() => handleRate(ticket.ticketId)}>Rate Provider</button>
            )}
            {ticket.status === 'CONFIRMED' && (
              <button className="btn" onClick={() => handlePrint(ticket)}>Print Ticket</button>
            )}
          </div>
        ))
      ) : (
        <p>No tickets booked yet.</p>
      )}
      <button className="btn" onClick={() => navigate('/userhome')}>Back to Home</button>
    </div>
  );
};

export default MyTickets;






The file 'PrintableTicket.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/PrintableTicket.jsx) contains:

import React, { useRef } from 'react';
import QRCode from 'qrcode';
import { useLocation, useNavigate } from 'react-router-dom';

const PrintableTicket = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { ticket } = location.state || {};
  const qrRef = useRef(null);

  if (!ticket) {
    return <div>No ticket data available.</div>;
  }

  // Constructing the exact QR code string with actual null characters
  const qrData = ticket.ticketId;
  console.log("QR Data (encoded key):", qrData);
  const handlePrint = () => {
    window.print();
  };

  const handleDownloadQR = async () => {
    try {
      const qrCanvas = await QRCode.toCanvas(qrData, { errorCorrectionLevel: 'L' });
      const pngUrl = qrCanvas.toDataURL('image/png');

      const link = document.createElement('a');
      link.href = pngUrl;
      link.download = `ticket-${ticket.ticketId}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('QR Code generation failed:', error);
    }
  };

  return (
    <div className="printable-ticket">
      <h2>Printable Ticket</h2>
      <div className="ticket-details">
        
        <p><strong>Seat Number:</strong> {ticket.seatNumber}</p>
        <p><strong>Booking Time:</strong> {ticket.bookingTime}</p>
        <p><strong>Status:</strong> {ticket.status}</p>
        {ticket.pricingBreakdown && (
          <>
            <p><strong>Base Price:</strong> {ticket.pricingBreakdown.basePrice}</p>
            <p><strong>Occupancy Factor:</strong> {ticket.pricingBreakdown.occupancyFactor}</p>
            <p><strong>Dynamic Factor:</strong> {ticket.pricingBreakdown.dynamicFactor}</p>
            <p><strong>Dynamic Price:</strong> {ticket.pricingBreakdown.dynamicPrice}</p>
          </>
        )}
      </div>
      <div className="qr-code" ref={qrRef}>
        <canvas id="qrcode"></canvas>
      </div>
      <button className="btn" onClick={handlePrint}>Print Ticket</button>
      <button className="btn" onClick={handleDownloadQR}>Download QR Code</button>
      <button className="btn" onClick={() => navigate(-1)}>Back</button>
    </div>
  );
};

export default PrintableTicket;



The file 'TicketVerification.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/TicketVerification.jsx) contains:

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import jsQR from 'jsqr';
import api from '../api';
const TicketVerification = () => {
  const [result, setResult] = useState('');
  const [verificationStatus, setVerificationStatus] = useState(null);
  const navigate = useNavigate();

  const handleQRUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
      const img = new Image();
      img.src = e.target.result;
      img.onload = () => processQR(img);
    };
    reader.readAsDataURL(file);
  };

  const processQR = (img) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0, img.width, img.height);

    const imageData = ctx.getImageData(0, 0, img.width, img.height);
    const qrCode = jsQR(imageData.data, img.width, img.height);
    // console.log(qrCode.data);
    if (qrCode) {
      const ticketId = qrCode.data.trim();
      console.log("Decoded Ticket ID:", ticketId);
      setResult(ticketId);
      verifyTicket(ticketId);
    } else {
      console.error("QR Code not detected");
      alert('Invalid QR Code');
    }
  };

  const verifyTicket = async (scannedTicketId) => {
  console.log("Scanned Ticket (encoded):", scannedTicketId);
  try {
    const response = await api.get(`/getticketdetails?ticketId=${encodeURIComponent(scannedTicketId)}`);
    const ticket = typeof response.data === 'string' ? JSON.parse(response.data) : response.data;
    
    if (ticket && ticket.status === 'CONFIRMED') {
      setVerificationStatus('Ticket Verified');
      alert('Ticket Verified for the seat number: ' + ticket.seatNumber);
    } else {
      setVerificationStatus('Ticket Not Verified');
      alert('Ticket Not Verified');
    }
  } catch (err) {
    console.error("API Error:", err);
    setVerificationStatus('Ticket Not Found or Error Occurred');
    alert('Ticket Not Found or Error Occurred');
  }
};













  return (
    <div className="ticket-verification">
      <h2>Ticket Verification</h2>
      <input type="file" accept="image/png, image/jpeg" onChange={handleQRUpload} />
      {verificationStatus && <p>{verificationStatus}</p>}
      <button className="btn" onClick={() => navigate(-1)}>Back</button>
    </div>
  );
};

export default TicketVerification;



The file 'UpdateCustomerDetails.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/UpdateCustomerDetails.jsx) contains:

// src/screens/UpdateCustomerDetails.jsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';
import { useAuth } from '../context/AuthContext';

const UpdateCustomerDetails = () => {
  const [newName, setNewName] = useState('');
  const [newContact, setNewContact] = useState('');
  const [isAnonymous, setIsAnonymous] = useState(false);
  const navigate = useNavigate();
  const { updateUserDetails } = useAuth();

  const handleUpdate = async () => {
    try {
      // Retrieve the customer's email from localStorage (set at login)
      const userEmail = localStorage.getItem('userEmail');
      if (!userEmail) {
        alert("Customer email not found. Please log in again.");
        return;
      }
      // Pass the email as a query parameter
      await api.post(`/updatecustomerdetails?email=${encodeURIComponent(userEmail)}`, { newName, newContact, isAnonymous });
      alert("Profile updated successfully!");
      await updateUserDetails(userEmail);
      navigate('/userhome');
    } catch (error) {
      console.error(error.response?.data || error.message);
      alert("Error updating profile");
    }
  };

  return (
    <div className="container">
      <h2>Update Customer Details</h2>
      <div className="inputDiv">
        <label>New Name:</label><br />
        <input type="text" value={newName} onChange={(e) => setNewName(e.target.value)} className="inputField" /><br />
        <label>New Contact:</label><br />
        <input type="text" value={newContact} onChange={(e) => setNewContact(e.target.value)} className="inputField" /><br />
        <label>
          <input type="checkbox" checked={isAnonymous} onChange={(e) => setIsAnonymous(e.target.checked)} /> Make Profile Anonymous
        </label><br />
        <button className="btn" onClick={handleUpdate}>Update Details</button>
      </div>
      <button className="btn" onClick={() => navigate('/userhome')}>Back</button>
    </div>
  );
};

export default UpdateCustomerDetails;






The file 'UpdateProviderDetails.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/UpdateProviderDetails.jsx) contains:

// src/screens/UpdateProviderDetails.jsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api';
import { useAuth } from '../context/AuthContext';

const UpdateProviderDetails = () => {
  const [newName, setNewName] = useState('');
  const [newContact, setNewContact] = useState('');
  const [newRating, setNewRating] = useState('');
  const [isAnonymous, setIsAnonymous] = useState(false);
  const navigate = useNavigate();
  const { updateUserDetails } = useAuth();
  const handleUpdate = async () => {
    try {
      await api.post('/updateproviderdetails', { providerEmail: localStorage.getItem('providerEmail'), newName, newContact, newRating:5, isAnonymous });
      alert("Profile updated successfully!");
      updateUserDetails();
      navigate('/providerhome');
    } catch (error) {
      console.error(error.response?.data || error.message);
      alert("Error updating profile");
    }
  };

  return (
    <div className="container">
      <h2>Update Provider Details</h2>
      <div className="inputDiv">
        <label>New Name:</label><br />
        <input type="text" value={newName} onChange={(e) => setNewName(e.target.value)} className="inputField" /><br />
        <label>New Contact:</label><br />
        <input type="text" value={newContact} onChange={(e) => setNewContact(e.target.value)} className="inputField" /><br />
        
        <button className="btn" onClick={handleUpdate}>Update Details</button>
      </div>
      <button className="btn" onClick={() => navigate('/providerhome')}>Back</button>
    </div>
  );
};

export default UpdateProviderDetails;






The file 'SeatSelection.jsx' (Path: /home/vboxuser/sec-try/fabric-samples/client/src/screens/SeatSelection.jsx) contains:

// src/SeatSelection.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import api from '../api';

const SeatSelection = () => {
  const navigate = useNavigate();
  const location = useLocation();
  // Extract travelOption and bookedSeats from location.state.
  const { travelOption, bookedSeats = [] } = location.state || {};

  // Declare hooks unconditionally.
  const [selectedSeat, setSelectedSeat] = useState(null);

  // If travelOption is not provided, use an effect to alert and navigate back.
  useEffect(() => {
    if (!travelOption) {
      alert('No travel option details provided.');
      navigate(-1);
    }
  }, [travelOption, navigate]);

  // If travelOption is not available, render nothing.
  if (!travelOption) return null;

  const seatCapacity = travelOption.seatCapacity;
  // Fixed grid: 10 columns per row.
  const cols = 10;
  const rows = Math.ceil(seatCapacity / 10);

  // Create an array representing all seat numbers (from 1 to seatCapacity).
  const seatsArray = Array.from({ length: seatCapacity }, (_, i) => i + 1);

  const handleSeatClick = (seatNum) => {
    if (bookedSeats.includes(seatNum)) {
      alert(`Seat ${seatNum} is already booked.`);
      return;
    }
    setSelectedSeat(seatNum);
  };

  const handleConfirmBooking = async () => {
    if (!selectedSeat) {
      alert('Please select a seat first.');
      return;
    }
    try {
      const userEmail = localStorage.getItem('userEmail');
      if (!userEmail) {
        alert("User email not found. Please log in again.");
        return;
      }
      const response = await api.post(
        `/bookticket?email=${encodeURIComponent(userEmail)}`,
        { travelOptionId: travelOption.travelOptionId, seatnumber: selectedSeat }
      );
      alert('Ticket booked successfully!');
      navigate('/myTickets');
    } catch (error) {
      console.error('Booking error:', error.response?.data || error.message);
      alert('Error booking ticket.');
    }
  };

  // Simple inline style for each seat cell.
  const seatStyle = (seatNum) => {
    const isBooked = bookedSeats.includes(seatNum);
    const isSelected = selectedSeat === seatNum;
    return {
      width: '40px',
      height: '40px',
      margin: '5px',
      backgroundColor: isBooked ? '#ff4d4d' : (isSelected ? '#4dff4d' : '#4CAF50'),
      color: '#fff',
      lineHeight: '40px',
      textAlign: 'center',
      cursor: isBooked ? 'not-allowed' : 'pointer',
      border: isSelected ? '3px solid #000' : '1px solid #333',
      borderRadius: '4px'
    };
  };

  return (
    <div style={{ padding: '20px', textAlign: 'center' }}>
      <h2>Select Your Seat</h2>
      <p>
        Travel Option: {travelOption.source} to {travelOption.destination} on {travelOption.departureDate} {travelOption.departureTime}
      </p>
      <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(10, 50px)', // Fixed 10 columns
          justifyContent: 'center',
          gap: '5px',
          marginBottom: '20px'
        }}>
        {seatsArray.map((seatNum) => (
          <div
            key={seatNum}
            style={seatStyle(seatNum)}
            onClick={() => handleSeatClick(seatNum)}
          >
            {seatNum}
          </div>
        ))}
      </div>
      {selectedSeat && <p>Selected Seat: {selectedSeat}</p>}
      <button className="btn" onClick={handleConfirmBooking}>Confirm Booking</button>
      <br />
      <button className="btn" onClick={() => navigate(-1)}>Back</button>
    </div>
  );
};

export default SeatSelection;





